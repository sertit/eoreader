<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc 0.9.2"/>
<title>eoreader.products.optical.landsat_product API documentation</title>
<meta name="description" content="Landsat products"/>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/darcula.min.css"
crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100%;padding:3em 4em;border-left:1px solid #ddd;overflow-x:hidden}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}table{display:block;overflow-x:auto;word-break:keep-all;border-collapse:separate;border-spacing:0}th{background-color:#c4d5e780;padding:5px;border-bottom:0.1px solid gray;border-right:0.1px solid gray;border-top:0.1px solid gray}td,th{margin:0}td{white-space:nowrap;border-bottom:0.1px solid gray;border-right:0.1px solid gray}td:empty{background-color:#ececec}th:nth-child(1){border-left:0.1px solid gray}td:nth-child(1){border-left:0.1px solid gray;border-right:0.1px solid gray}th:nth-child(1),td:nth-child(1){background-color:#c4d5e7;position:-webkit-sticky;position:sticky;left:0}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML"
integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"
integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>eoreader.products.optical.landsat_product</code></h1>
</header>
<section id="section-intro">
<p>Landsat products</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; Landsat products &#34;&#34;&#34;
import glob
import logging
import os
import tarfile
from abc import abstractmethod
from datetime import datetime
from enum import unique
from typing import Tuple, Union

import geopandas as gpd
import numpy as np
import pandas as pd
from lxml import etree
from rasterio.enums import Resampling

from eoreader.bands.alias import ALL_CLOUDS, CIRRUS, CLOUDS, RAW_CLOUDS, SHADOWS
from eoreader.bands.bands import BandNames
from eoreader.bands.bands import OpticalBandNames as obn
from eoreader.exceptions import InvalidProductError, InvalidTypeError
from eoreader.products.optical.optical_product import OpticalProduct
from eoreader.utils import DATETIME_FMT, EOREADER_NAME
from sertit import files, rasters
from sertit.misc import ListEnum
from sertit.rasters import XDS_TYPE

LOGGER = logging.getLogger(EOREADER_NAME)


@unique
class LandsatProductType(ListEnum):
    &#34;&#34;&#34;Landsat products types&#34;&#34;&#34;

    L1_OLCI = &#34;OLCI&#34;
    &#34;&#34;&#34;OLCI Product Type, for Landsat-8 platform&#34;&#34;&#34;

    L1_ETM = &#34;ETM&#34;
    &#34;&#34;&#34;ETM Product Type, for Landsat-7 platform&#34;&#34;&#34;

    L1_TM = &#34;TM&#34;
    &#34;&#34;&#34;TM Product Type, for Landsat-5 and 4 platforms&#34;&#34;&#34;

    L1_MSS = &#34;MSS&#34;
    &#34;&#34;&#34;MSS Product Type, for Landsat-5, 4, 3, 2, 1 platforms&#34;&#34;&#34;


@unique
class LandsatCollection(ListEnum):
    &#34;&#34;&#34;
    Landsat collection number.
    See [here](https://www.usgs.gov/media/files/landsat-collection-1-vs-collection-2-summary) for more information
    &#34;&#34;&#34;

    COL_1 = &#34;01&#34;
    &#34;&#34;&#34;Collection 1&#34;&#34;&#34;

    COL_2 = &#34;02&#34;
    &#34;&#34;&#34;Collection 2&#34;&#34;&#34;


class LandsatProduct(OpticalProduct):
    &#34;&#34;&#34;
    Super Class of Landsat Products

    You can use directly the .tar file in case of collection 2 products.
    &#34;&#34;&#34;

    def __init__(
        self, product_path: str, archive_path: str = None, output_path=None
    ) -&gt; None:
        # Private
        self._collection = None
        self._quality_id = None

        # Initialization from the super class
        super().__init__(product_path, archive_path, output_path)

    def _set_collection(self):
        &#34;&#34;&#34;Set Landsat collection&#34;&#34;&#34;
        return LandsatCollection.from_value(self.split_name[-2])

    def _post_init(self) -&gt; None:
        &#34;&#34;&#34;
        Function used to post_init the products
        (setting sensor type, band names and so on)
        &#34;&#34;&#34;
        self.tile_name = self._get_tile_name()
        self._collection = self._set_collection()
        if self._collection == LandsatCollection.COL_1:
            self._quality_id = &#34;_BQA&#34;
            self._nodata_band_id = &#34;_BQA&#34;
            self.needs_extraction = True  # Too slow to read directly tar.gz files
        else:
            self._quality_id = &#34;_QA_RADSAT&#34;
            self._nodata_band_id = &#34;_QA_PIXEL&#34;
            self.needs_extraction = False  # Fine to read .tar files

        # Post init done by the super class
        super()._post_init()

    def _get_path(self, band_id: str) -&gt; str:
        &#34;&#34;&#34;
        Get either the archived path of the normal path of a tif file

        Args:
            band_id (str): Band ID

        Returns:
            str: band path

        &#34;&#34;&#34;
        if self.is_archived:
            # Because of gap_mask files that have the same name structure and exists only for L7
            if self.product_type == LandsatProductType.L1_ETM:
                regex = f&#34;.*RT{band_id}.*&#34;
            else:
                regex = f&#34;.*{band_id}.*&#34;
            path = files.get_archived_rio_path(self.path, regex)
        else:
            path = files.get_file_in_dir(self.path, band_id, extension=&#34;TIF&#34;)

        return path

    def footprint(self) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;
        Get real footprint of the products (without nodata, in french == emprise utile)

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;LC08_L1GT_023030_20200518_20200527_01_T2&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.footprint()
           index                                           geometry
        0      0  POLYGON ((366165.000 4899735.000, 366165.000 4...
        ```

        Overload of the generic function because landsat nodata seems to be different in QA than in regular bands.
        Indeed, nodata pixels vary according to the band sensor footprint,
        whereas QA nodata is where at least one band has nodata.

        We chose to keep QA nodata values for the footprint in order to show where all bands are valid.

        **TL;DR: We use the QA nodata value to determine the product&#39;s footprint**.

        Returns:
            gpd.GeoDataFrame: Footprint as a GeoDataFrame
        &#34;&#34;&#34;
        nodata_band = self._get_path(self._nodata_band_id)

        # Vectorize the nodata band
        nodata = rasters.vectorize(nodata_band, values=1)

        # Clip the extent with the nodata
        footprint = gpd.overlay(self.extent(), nodata, how=&#34;symmetric_difference&#34;)

        return footprint

    def _get_tile_name(self) -&gt; str:
        &#34;&#34;&#34;
        Retrieve tile name

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;LC08_L1GT_023030_20200518_20200527_01_T2&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_tile_name()
        &#39;023030&#39;
        ```

        Returns:
            str: Tile name
        &#34;&#34;&#34;
        return self.split_name[2]

    @abstractmethod
    def _set_product_type(self) -&gt; None:
        &#34;&#34;&#34;Get products type&#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _set_mss_product_type(self, version: int) -&gt; None:
        &#34;&#34;&#34;Set MSS product type and map corresponding bands&#34;&#34;&#34;
        if &#34;L1&#34; in self.name:
            self.product_type = LandsatProductType.L1_MSS
            self.band_names.map_bands(
                {
                    obn.GREEN: &#34;4&#34; if version &lt; 4 else &#34;1&#34;,
                    obn.RED: &#34;5&#34; if version &lt; 4 else &#34;2&#34;,
                    obn.VRE_1: &#34;6&#34; if version &lt; 4 else &#34;3&#34;,
                    obn.VRE_2: &#34;6&#34; if version &lt; 4 else &#34;3&#34;,
                    obn.VRE_3: &#34;6&#34; if version &lt; 4 else &#34;3&#34;,
                    obn.NIR: &#34;7&#34; if version &lt; 4 else &#34;4&#34;,
                    obn.NARROW_NIR: &#34;7&#34; if version &lt; 4 else &#34;4&#34;,
                }
            )
        else:
            raise InvalidProductError(&#34;Only Landsat level 1 are managed in EOReader&#34;)

    def _set_tm_product_type(self) -&gt; None:
        &#34;&#34;&#34;Set TM product type and map corresponding bands&#34;&#34;&#34;
        if &#34;L1&#34; in self.name:
            self.product_type = LandsatProductType.L1_TM
            self.band_names.map_bands(
                {
                    obn.BLUE: &#34;1&#34;,
                    obn.GREEN: &#34;2&#34;,
                    obn.RED: &#34;3&#34;,
                    obn.NIR: &#34;4&#34;,
                    obn.NARROW_NIR: &#34;4&#34;,
                    obn.SWIR_1: &#34;5&#34;,
                    obn.SWIR_2: &#34;7&#34;,
                    obn.TIR_1: &#34;6&#34;,
                    obn.TIR_2: &#34;6&#34;,
                }
            )
        else:
            raise InvalidProductError(&#34;Only Landsat level 1 are managed in EOReader&#34;)

    def _set_etm_product_type(self) -&gt; None:
        &#34;&#34;&#34;Set ETM product type and map corresponding bands&#34;&#34;&#34;
        if &#34;L1&#34; in self.name:
            self.product_type = LandsatProductType.L1_ETM
            self.band_names.map_bands(
                {
                    obn.BLUE: &#34;1&#34;,
                    obn.GREEN: &#34;2&#34;,
                    obn.RED: &#34;3&#34;,
                    obn.NIR: &#34;4&#34;,
                    obn.NARROW_NIR: &#34;4&#34;,
                    obn.SWIR_1: &#34;5&#34;,
                    obn.SWIR_2: &#34;7&#34;,
                    obn.PAN: &#34;8&#34;,
                    obn.TIR_1: &#34;6_VCID_1&#34;,
                    obn.TIR_2: &#34;6_VCID_2&#34;,
                }
            )
        else:
            raise InvalidProductError(&#34;Only Landsat level 1 are managed in EOReader&#34;)

    def _set_olci_product_type(self) -&gt; None:
        &#34;&#34;&#34;Set OLCI product type and map corresponding bands&#34;&#34;&#34;
        if &#34;L1&#34; in self.name:
            self.product_type = LandsatProductType.L1_OLCI
            self.band_names.map_bands(
                {
                    obn.CA: &#34;1&#34;,
                    obn.BLUE: &#34;2&#34;,
                    obn.GREEN: &#34;3&#34;,
                    obn.RED: &#34;4&#34;,
                    obn.NIR: &#34;5&#34;,
                    obn.NARROW_NIR: &#34;5&#34;,
                    obn.SWIR_1: &#34;6&#34;,
                    obn.SWIR_2: &#34;7&#34;,
                    obn.PAN: &#34;8&#34;,
                    obn.SWIR_CIRRUS: &#34;9&#34;,
                    obn.TIR_1: &#34;10&#34;,
                    obn.TIR_2: &#34;11&#34;,
                }
            )
        else:
            raise InvalidProductError(&#34;Only Landsat level 1 are managed in EOReader&#34;)

    def get_datetime(self, as_datetime: bool = False) -&gt; Union[str, datetime]:
        &#34;&#34;&#34;
        Get the product&#39;s acquisition datetime, with format `YYYYMMDDTHHMMSS` &lt;-&gt; `%Y%m%dT%H%M%S`

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;LC08_L1GT_023030_20200518_20200527_01_T2&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_datetime(as_datetime=True)
        datetime.datetime(2020, 5, 18, 16, 34, 7)
        &gt;&gt;&gt; prod.get_datetime(as_datetime=False)
        &#39;20200518T163407&#39;
        ```

        Args:
            as_datetime (bool): Return the date as a datetime.datetime. If false, returns a string.

        Returns:
             Union[str, datetime.datetime]: Its acquisition datetime
        &#34;&#34;&#34;
        try:
            mtd = self.read_mtd(force_pd=True)
            date = mtd[&#34;DATE_ACQUIRED&#34;].value  # 1982-09-06
            # &#34;16:47:09.5990000Z&#34;: needs max 6 digits for ms
            hours = mtd[&#34;SCENE_CENTER_TIME&#34;].value.replace(&#39;&#34;&#39;, &#34;&#34;)[:-3]

            date = (
                f&#34;{datetime.strptime(date, &#39;%Y-%m-%d&#39;).strftime(&#39;%Y%m%d&#39;)}&#34;
                f&#34;T{datetime.strptime(hours, &#39;%H:%M:%S.%f&#39;).strftime(&#39;%H%M%S&#39;)}&#34;
            )
        except (FileNotFoundError, KeyError):
            date = datetime.strptime(self.split_name[3], &#34;%Y%m%d&#34;).strftime(
                DATETIME_FMT
            )

        if as_datetime:
            date = datetime.strptime(date, DATETIME_FMT)

        return date

    def get_band_paths(self, band_list: list, resolution: float = None) -&gt; dict:
        &#34;&#34;&#34;
        Return the paths of required bands.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
        {
            &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;:
                &#39;LC08_L1GT_023030_20200518_20200527_01_T2\\LC08_L1GT_023030_20200518_20200527_01_T2_B3.TIF&#39;,
            &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;:
                &#39;LC08_L1GT_023030_20200518_20200527_01_T2\\LC08_L1GT_023030_20200518_20200527_01_T2_B4.TIF&#39;
        }

        ```

        Args:
            band_list (list): List of the wanted bands
            resolution (float): Useless here

        Returns:
            dict: Dictionary containing the path of each queried band
        &#34;&#34;&#34;
        band_paths = {}
        for band in band_list:
            if not self.has_band(band):
                raise InvalidProductError(
                    f&#34;Non existing band ({band.name}) &#34;
                    f&#34;for Landsat-{self.product_type.name} products&#34;
                )
            band_nb = self.band_names[band]

            try:
                band_paths[band] = self._get_path(f&#34;_B{band_nb}&#34;)
            except FileNotFoundError as ex:
                raise InvalidProductError(
                    f&#34;Non existing {band} ({band_nb}) band for {self.path}&#34;
                ) from ex

        return band_paths

    def read_mtd(
        self, force_pd=False
    ) -&gt; Union[pd.DataFrame, Tuple[etree._Element, str]]:
        &#34;&#34;&#34;
        Read Landsat metadata as:

         - a `pandas.DataFrame` whatever its collection is (by default for collection 1)
         - a XML root + its namespace if the product is retrieved from the 2nd collection (by default for collection 2)

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;LC08_L1GT_023030_20200518_20200527_01_T2&#34;
        &gt;&gt;&gt; prod = Reader().open(path)

        &gt;&gt;&gt; # COLLECTION 1 : Open metadata as panda DataFrame
        &gt;&gt;&gt; prod.read_mtd()
        NAME                                           ORIGIN  ...    RESAMPLING_OPTION
        value  &#34;Image courtesy of the U.S. Geological Survey&#34;  ...  &#34;CUBIC_CONVOLUTION&#34;
        [1 rows x 197 columns]

        &gt;&gt;&gt; # COLLECTION 2 : Open metadata as XML
        &gt;&gt;&gt; path = r&#34;LC08_L1TP_200030_20201220_20210310_02_T1&#34;  # Collection 2
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.read_mtd()
        (&lt;Element LANDSAT_METADATA_FILE at 0x19229016048&gt;, &#39;&#39;)

        &gt;&gt;&gt; # COLLECTION 2 : Force to pandas.DataFrame
        &gt;&gt;&gt; prod.read_mtd(force_pd=True)
        NAME                                           ORIGIN  ...    RESAMPLING_OPTION
        value  &#34;Image courtesy of the U.S. Geological Survey&#34;  ...  &#34;CUBIC_CONVOLUTION&#34;
        [1 rows x 263 columns]
        ```
        Args:
            force_pd (bool): If collection 2, return a pandas.DataFrame instead of a XML root + namespace
        Returns:
            pd.DataFrame: Metadata as a Pandas DataFrame
        &#34;&#34;&#34;
        # WARNING: always use force_pd in this class !
        as_pd = (self._collection == LandsatCollection.COL_1) or force_pd

        if as_pd:
            mtd_name = f&#34;{self.name}_MTL.txt&#34;
            if self.is_archived:
                # We need to extract the file in memry to be used with pandas
                tar_ds = tarfile.open(self.path, &#34;r&#34;)
                info = [f.name for f in tar_ds.getmembers() if mtd_name in f.name][0]
                mtd_path = tar_ds.extractfile(info)
            else:
                # FOR COLLECTION 1 AND 2
                tar_ds = None
                mtd_path = os.path.join(self.path, mtd_name)

                if not os.path.isfile(mtd_path):
                    raise FileNotFoundError(
                        f&#34;Unable to find the metadata file associated with {self.path}&#34;
                    )

            # Parse
            mtd_data = pd.read_table(
                mtd_path,
                sep=&#34;\s=\s&#34;,
                names=[&#34;NAME&#34;, &#34;value&#34;],
                skipinitialspace=True,
                engine=&#34;python&#34;,
            )

            # Workaround an unexpected behaviour in pandas !
            if any(mtd_data.NAME == &#34;=&#34;):
                mtd_data = pd.read_table(
                    mtd_path,
                    sep=&#34;=&#34;,
                    names=[&#34;NAME&#34;, &#34;=&#34;, &#34;value&#34;],
                    usecols=[0, 2],
                    skipinitialspace=True,
                )

            # Remove useless rows
            mtd_data = mtd_data[~mtd_data[&#34;NAME&#34;].isin([&#34;GROUP&#34;, &#34;END_GROUP&#34;, &#34;END&#34;])]

            # Set index
            mtd_data = mtd_data.set_index(&#34;NAME&#34;).T

            # Close if needed
            if tar_ds:
                tar_ds.close()
        else:
            if self.is_archived:
                root = files.read_archived_xml(self.path, f&#34;.*{self.name}_MTL.xml&#34;)
            else:
                # ONLY FOR COLLECTION 2
                try:
                    mtd_file = glob.glob(
                        os.path.join(self.path, f&#34;{self.name}_MTL.xml&#34;)
                    )[0]

                    # pylint: disable=I1101:
                    # Module &#39;lxml.etree&#39; has no &#39;parse&#39; member, but source is unavailable.
                    xml_tree = etree.parse(mtd_file)
                    root = xml_tree.getroot()
                except IndexError as ex:
                    raise InvalidProductError(
                        f&#34;Metadata file ({self.name}.xml) not found in {self.path}&#34;
                    ) from ex

            # Get namespace
            namespace = &#34;&#34;  # No namespace here

            mtd_data = (root, namespace)

        return mtd_data

    def _read_band(
        self,
        path: str,
        resolution: Union[tuple, list, float] = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Read band from a dataset.

        .. WARNING::
            Invalid pixels are not managed here !

        Args:
            path (str): Band path
            resolution (Union[tuple, list, float]): Resolution of the wanted band, in dataset resolution unit (X, Y)
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            XDS_TYPE: Radiometrically coherent band, saved as float 32 and its metadata

        &#34;&#34;&#34;
        # Get band name: the last number of the filename:
        # ie: &#39;LC08_L1TP_200030_20191218_20191226_01_T1_B1&#39;
        if self.is_archived:
            filename = files.get_filename(path.split(&#34;!&#34;)[-1])
        else:
            filename = files.get_filename(path)

        band_name = filename[-1]
        if self._quality_id in filename or self._nodata_band_id in filename:
            band = rasters.read(
                path,
                resolution=resolution,
                size=size,
                resampling=Resampling.nearest,  # NEAREST TO KEEP THE FLAGS
                masked=False,
            ).astype(np.uint16)
        else:
            # Read band (call superclass generic method)
            band = rasters.read(
                path, resolution=resolution, size=size, resampling=Resampling.bilinear
            ).astype(np.float32)

            # Open mtd
            mtd_data = self.read_mtd(force_pd=True)

            # Get band nb and corresponding coeff
            c_mul_str = &#34;REFLECTANCE_MULT_BAND_&#34; + band_name
            c_add_str = &#34;REFLECTANCE_ADD_BAND_&#34; + band_name

            # Get coeffs to convert DN to reflectance
            c_mul = mtd_data[c_mul_str].value
            c_add = mtd_data[c_add_str].value

            # Manage NULL values
            try:
                c_mul = float(c_mul)
            except ValueError:
                c_mul = 1
            try:
                c_add = float(c_add)
            except ValueError:
                c_add = 0

            # Compute the correct radiometry of the band and set no data to 0
            band = c_mul * band + c_add  # Already in float

        return band

    # pylint: disable=R0913
    # R0913: Too many arguments (6/5) (too-many-arguments)
    def _manage_invalid_pixels(
        self,
        band_arr: XDS_TYPE,
        band: obn,
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Manage invalid pixels (Nodata, saturated, defective...)

        Args:
            band_arr (XDS_TYPE): Band array
            band (obn): Band name as an OpticalBandNames
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            XDS_TYPE: Cleaned band array
        &#34;&#34;&#34;
        # Open QA band
        landsat_qa_path = self._get_path(self._quality_id)
        qa_arr = self._read_band(
            landsat_qa_path, resolution=resolution, size=size
        ).data  # To np array

        if self._collection == LandsatCollection.COL_1:
            # https://www.usgs.gov/core-science-systems/nli/landsat/landsat-collection-1-level-1-quality-assessment-band
            # Bit ids
            nodata_id = 0  # Fill value
            dropped_id = 1  # Dropped pixel or terrain occlusion
            # Set nodata to every saturated pixel, even if only 1-2 bands are touched by it
            # -&gt; 01 or 10 or 11
            # -&gt; bit 2 or bit 3
            sat_id_1 = 2
            sat_id_2 = 3
            nodata, dropped, sat_1, sat_2 = rasters.read_bit_array(
                qa_arr, [nodata_id, dropped_id, sat_id_1, sat_id_2]
            )
            mask = nodata | dropped | sat_1 | sat_2
        else:
            # https://www.usgs.gov/core-science-systems/nli/landsat/landsat-collection-2-quality-assessment-bands
            # SATURATED &amp; OTHER PIXELS
            band_nb = int(self.band_names[band])

            # Bit ids
            sat_id = band_nb - 1  # Saturated pixel
            if self.product_type != LandsatProductType.L1_OLCI:
                other_id = 11  # Terrain occlusion
            else:
                other_id = 9  # Dropped pixels

            sat, other = rasters.read_bit_array(qa_arr, [sat_id, other_id])

            # If collection 2, nodata has to be found in pixel QA file
            landsat_stat_path = self._get_path(self._nodata_band_id)
            pixel_arr = self._read_band(
                landsat_stat_path, resolution=resolution, size=size
            ).data
            nodata = np.where(pixel_arr == 1, 1, 0)

            mask = sat | other | nodata

        return self._set_nodata_mask(band_arr, mask)

    def _load_bands(
        self,
        band_list: Union[list, BandNames],
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load bands as numpy arrays with the same resolution (and same metadata).

        Args:
            band_list (list, BandNames): List of the wanted bands
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        # Return empty if no band are specified
        if not band_list:
            return {}

        # Get band paths
        if not isinstance(band_list, list):
            band_list = [band_list]
        band_paths = self.get_band_paths(band_list)

        # Open bands and get array (resampled if needed)
        band_arrays = self._open_bands(band_paths, resolution=resolution, size=size)

        return band_arrays

    def get_mean_sun_angles(self) -&gt; (float, float):
        &#34;&#34;&#34;
        Get Mean Sun angles (Azimuth and Zenith angles)

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;LC08_L1GT_023030_20200518_20200527_01_T2.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_mean_sun_angles()
        (140.80752656, 61.93065805)
        ```

        Returns:
            (float, float): Mean Azimuth and Zenith angle
        &#34;&#34;&#34;
        # Retrieve angles
        mtd_data = self.read_mtd(force_pd=True)
        azimuth_angle = float(mtd_data.SUN_AZIMUTH.value)
        zenith_angle = float(mtd_data.SUN_ELEVATION.value)

        return azimuth_angle, zenith_angle

    @abstractmethod
    def _get_condensed_name(self) -&gt; str:
        &#34;&#34;&#34;
        Get products condensed name ({date}_Lx_{tile}_{product_type}).

        Returns:
            str: Condensed Landsat name
        &#34;&#34;&#34;
        return f&#34;{self.get_datetime()}_{self.platform.name}_{self.tile_name}_{self.product_type.value}&#34;

    def _has_cloud_band(self, band: BandNames) -&gt; bool:
        &#34;&#34;&#34;
        Does this products has the specified cloud band ?

        - (COL 1)[https://www.usgs.gov/land-resources/nli/landsat/landsat-collection-1-level-1-quality-assessment-band]
        - (COL 2)[https://www.usgs.gov/core-science-systems/nli/landsat/landsat-collection-2-quality-assessment-bands]
        True
        ```
        &#34;&#34;&#34;
        if self.product_type == LandsatProductType.L1_OLCI:
            has_band = True
        elif self.product_type in [LandsatProductType.L1_ETM, LandsatProductType.L1_TM]:
            has_band = self._e_tm_has_cloud_band(band)
        elif self.product_type == LandsatProductType.L1_MSS:
            has_band = self._mss_has_cloud_band(band)
        else:
            raise InvalidProductError(f&#34;Invalid product type: {self.product_type}&#34;)

        return has_band

    @staticmethod
    def _mss_has_cloud_band(band: BandNames) -&gt; bool:
        &#34;&#34;&#34;
        Does this products has the specified cloud band ?
        ```
        &#34;&#34;&#34;
        if band in [RAW_CLOUDS, CLOUDS, ALL_CLOUDS]:
            has_band = True
        else:
            has_band = False
        return has_band

    @staticmethod
    def _e_tm_has_cloud_band(band: BandNames) -&gt; bool:
        &#34;&#34;&#34;
        Does this products has the specified cloud band ?
        ```
        &#34;&#34;&#34;
        if band in [RAW_CLOUDS, CLOUDS, ALL_CLOUDS, SHADOWS]:
            has_band = True
        else:
            has_band = False
        return has_band

    def _load_clouds(
        self, bands: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load cloud files as numpy arrays with the same resolution (and same metadata).

        Read Landsat clouds from QA mask.
        See here for clouds_values:

        - (COL 1)[https://www.usgs.gov/land-resources/nli/landsat/landsat-collection-1-level-1-quality-assessment-band]
        - (COL 2)[https://www.usgs.gov/core-science-systems/nli/landsat/landsat-collection-2-quality-assessment-bands]


        Args:
            bands (list): List of the wanted bands
            resolution (int): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        band_dict = {}

        if bands:
            # Open QA band
            landsat_qa_path = self._get_path(self._quality_id)
            qa_arr = self._read_band(landsat_qa_path, resolution=resolution, size=size)

            if self.product_type == LandsatProductType.L1_OLCI:
                band_dict = self._load_olci_clouds(qa_arr, bands)
            elif self.product_type in [
                LandsatProductType.L1_ETM,
                LandsatProductType.L1_TM,
            ]:
                band_dict = self._load_e_tm_clouds(qa_arr, bands)
            elif self.product_type == LandsatProductType.L1_MSS:
                band_dict = self._load_mss_clouds(qa_arr, bands)
            else:
                raise InvalidProductError(f&#34;Invalid product type: {self.product_type}&#34;)

        return band_dict

    def _load_mss_clouds(self, qa_arr: XDS_TYPE, band_list: list) -&gt; dict:
        &#34;&#34;&#34;
        Load cloud files as numpy arrays with the same resolution (and same metadata).

        Read Landsat-MSS clouds from QA mask.
        See here for clouds_values:

        - (COL 1)[https://www.usgs.gov/land-resources/nli/landsat/landsat-collection-1-level-1-quality-assessment-band]
        - (COL 2)[https://www.usgs.gov/media/files/landsat-1-5-mss-collection-2-level-1-data-format-control-book]


        Args:
            qa_arr (XDS_TYPE): Quality array
            band_list (list): List of the wanted bands
        Returns:
            dict, dict: Dictionary {band_name, band_array}
        &#34;&#34;&#34;
        bands = {}

        # Get clouds and nodata
        nodata_id = 0
        cloud_id = (
            4 if self._collection == LandsatCollection.COL_1 else 3
        )  # Clouds with high confidence

        clouds = None
        if ALL_CLOUDS in band_list or CLOUDS in band_list:
            nodata, cld = rasters.read_bit_array(qa_arr, [nodata_id, cloud_id])
            clouds = self._create_mask(qa_arr, cld, nodata)

        for band in band_list:
            if band == ALL_CLOUDS:
                bands[band] = clouds
            elif band == CLOUDS:
                bands[band] = clouds
            elif band == RAW_CLOUDS:
                bands[band] = qa_arr
            else:
                raise InvalidTypeError(
                    f&#34;Non existing cloud band for Landsat-MSS sensor: {band}&#34;
                )

        return bands

    def _load_e_tm_clouds(
        self, qa_arr: XDS_TYPE, band_list: Union[list, BandNames]
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load cloud files as numpy arrays with the same resolution (and same metadata).

        Read Landsat-(E)TM clouds from QA mask.
        See here for clouds_values:

        - (COL 1)[https://www.usgs.gov/land-resources/nli/landsat/landsat-collection-1-level-1-quality-assessment-band]
        - (COL 2 TM)[https://www.usgs.gov/media/files/landsat-4-5-tm-collection-2-level-1-data-format-control-book]
        - (COL 2 ETM)[https://www.usgs.gov/media/files/landsat-7-etm-collection-2-level-1-data-format-control-book]


        Args:
            qa_arr (XDS_TYPE): Quality array
            band_list (list): List of the wanted bands
        Returns:
            dict, dict: Dictionary {band_name, band_array}
        &#34;&#34;&#34;
        bands = {}

        # Get clouds and nodata
        nodata = None
        cld = None
        shd = None
        if any(band in [ALL_CLOUDS, CLOUDS, SHADOWS] for band in band_list):
            if self._collection == LandsatCollection.COL_1:
                # Bit id
                nodata_id = 0
                cloud_id = 4  # Clouds with high confidence
                shd_conf_1_id = 7
                shd_conf_2_id = 8
                nodata, cld, shd_conf_1, shd_conf_2 = rasters.read_bit_array(
                    qa_arr, [nodata_id, cloud_id, shd_conf_1_id, shd_conf_2_id]
                )
                shd = shd_conf_1 &amp; shd_conf_2
            else:
                # Bit ids
                nodata_id = 0
                cloud_id = 3  # Clouds with high confidence
                shd_id = 4  # Shadows with high confidence
                nodata, cld, shd = rasters.read_bit_array(
                    qa_arr, [nodata_id, cloud_id, shd_id]
                )

        for band in band_list:
            if band == ALL_CLOUDS:
                bands[band] = self._create_mask(qa_arr, cld | shd, nodata)
            elif band == SHADOWS:
                bands[band] = self._create_mask(qa_arr, shd, nodata)
            elif band == CLOUDS:
                bands[band] = self._create_mask(qa_arr, cld, nodata)
            elif band == RAW_CLOUDS:
                bands[band] = qa_arr
            else:
                raise InvalidTypeError(
                    f&#34;Non existing cloud band for Landsat-(E)TM sensor: {band}&#34;
                )

        return bands

    def _load_olci_clouds(
        self, qa_arr: XDS_TYPE, band_list: Union[list, BandNames]
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load cloud files as numpy arrays with the same resolution (and same metadata).

        Read Landsat-OLCI clouds from QA mask.
        See here for clouds_values:

        - (COL 1)[https://www.usgs.gov/land-resources/nli/landsat/landsat-collection-1-level-1-quality-assessment-band]
        - (COL 2)[https://www.usgs.gov/media/files/landsat-8-level-1-data-format-control-book]


        Args:
            qa_arr (XDS_TYPE): Quality array
            band_list (list): List of the wanted bands
        Returns:
            dict, dict: Dictionary {band_name, band_array}
        &#34;&#34;&#34;
        bands = {}

        # Get clouds and nodata
        nodata = None
        cld = None
        shd = None
        cir = None
        if any(band in [ALL_CLOUDS, CLOUDS, SHADOWS] for band in band_list):
            if self._collection == LandsatCollection.COL_1:
                # Bit ids
                nodata_id = 0
                cloud_id = 4  # Clouds with high confidence
                shd_conf_1_id = 7
                shd_conf_2_id = 8
                cir_conf_1_id = 11
                cir_conf_2_id = 12

                # Read binary mask
                (
                    nodata,
                    cld,
                    shd_conf_1,
                    shd_conf_2,
                    cir_conf_1,
                    cir_conf_2,
                ) = rasters.read_bit_array(
                    qa_arr,
                    [
                        nodata_id,
                        cloud_id,
                        shd_conf_1_id,
                        shd_conf_2_id,
                        cir_conf_1_id,
                        cir_conf_2_id,
                    ],
                )

                shd = shd_conf_1 &amp; shd_conf_2
                cir = cir_conf_1 &amp; cir_conf_2
            else:
                # Bit ids
                nodata_id = 0
                cloud_id = 3  # Clouds with high confidence
                shd_id = 4  # Shadows with high confidence
                cir_id = 2  # Cirrus with high confidence
                nodata, cld, shd, cir = rasters.read_bit_array(
                    qa_arr, [nodata_id, cloud_id, shd_id, cir_id]
                )

        for band in band_list:
            if band == ALL_CLOUDS:
                bands[band] = self._create_mask(qa_arr, cld | shd | cir, nodata)
            elif band == SHADOWS:
                bands[band] = self._create_mask(qa_arr, shd, nodata)
            elif band == CLOUDS:
                bands[band] = self._create_mask(qa_arr, cld, nodata)
            elif band == CIRRUS:
                bands[band] = self._create_mask(qa_arr, cir, nodata)
            elif band == RAW_CLOUDS:
                bands[band] = qa_arr
            else:
                raise InvalidTypeError(
                    f&#34;Non existing cloud band for Landsat-OLCI sensor: {band}&#34;
                )

        return bands</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="eoreader.products.optical.landsat_product.LandsatProductType"><code class="flex name class">
<span>class <span class="ident">LandsatProductType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Landsat products types</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LandsatProductType(ListEnum):
    &#34;&#34;&#34;Landsat products types&#34;&#34;&#34;

    L1_OLCI = &#34;OLCI&#34;
    &#34;&#34;&#34;OLCI Product Type, for Landsat-8 platform&#34;&#34;&#34;

    L1_ETM = &#34;ETM&#34;
    &#34;&#34;&#34;ETM Product Type, for Landsat-7 platform&#34;&#34;&#34;

    L1_TM = &#34;TM&#34;
    &#34;&#34;&#34;TM Product Type, for Landsat-5 and 4 platforms&#34;&#34;&#34;

    L1_MSS = &#34;MSS&#34;
    &#34;&#34;&#34;MSS Product Type, for Landsat-5, 4, 3, 2, 1 platforms&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sertit.misc.ListEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eoreader.products.optical.landsat_product.LandsatProductType.L1_OLCI"><code class="name">var <span class="ident">L1_OLCI</span></code>
</dt>
<dd>
<div class="desc"><p>OLCI Product Type, for Landsat-8 platform</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProductType.L1_ETM"><code class="name">var <span class="ident">L1_ETM</span></code>
</dt>
<dd>
<div class="desc"><p>ETM Product Type, for Landsat-7 platform</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProductType.L1_TM"><code class="name">var <span class="ident">L1_TM</span></code>
</dt>
<dd>
<div class="desc"><p>TM Product Type, for Landsat-5 and 4 platforms</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProductType.L1_MSS"><code class="name">var <span class="ident">L1_MSS</span></code>
</dt>
<dd>
<div class="desc"><p>MSS Product Type, for Landsat-5, 4, 3, 2, 1 platforms</p></div>
</dd>
</dl>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatCollection"><code class="flex name class">
<span>class <span class="ident">LandsatCollection</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Landsat collection number.
See <a href="https://www.usgs.gov/media/files/landsat-collection-1-vs-collection-2-summary">here</a> for more information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LandsatCollection(ListEnum):
    &#34;&#34;&#34;
    Landsat collection number.
    See [here](https://www.usgs.gov/media/files/landsat-collection-1-vs-collection-2-summary) for more information
    &#34;&#34;&#34;

    COL_1 = &#34;01&#34;
    &#34;&#34;&#34;Collection 1&#34;&#34;&#34;

    COL_2 = &#34;02&#34;
    &#34;&#34;&#34;Collection 2&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sertit.misc.ListEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eoreader.products.optical.landsat_product.LandsatCollection.COL_1"><code class="name">var <span class="ident">COL_1</span></code>
</dt>
<dd>
<div class="desc"><p>Collection 1</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatCollection.COL_2"><code class="name">var <span class="ident">COL_2</span></code>
</dt>
<dd>
<div class="desc"><p>Collection 2</p></div>
</dd>
</dl>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct"><code class="flex name class">
<span>class <span class="ident">LandsatProduct</span></span>
<span>(</span><span>product_path, archive_path=None, output_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Super Class of Landsat Products</p>
<p>You can use directly the .tar file in case of collection 2 products.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LandsatProduct(OpticalProduct):
    &#34;&#34;&#34;
    Super Class of Landsat Products

    You can use directly the .tar file in case of collection 2 products.
    &#34;&#34;&#34;

    def __init__(
        self, product_path: str, archive_path: str = None, output_path=None
    ) -&gt; None:
        # Private
        self._collection = None
        self._quality_id = None

        # Initialization from the super class
        super().__init__(product_path, archive_path, output_path)

    def _set_collection(self):
        &#34;&#34;&#34;Set Landsat collection&#34;&#34;&#34;
        return LandsatCollection.from_value(self.split_name[-2])

    def _post_init(self) -&gt; None:
        &#34;&#34;&#34;
        Function used to post_init the products
        (setting sensor type, band names and so on)
        &#34;&#34;&#34;
        self.tile_name = self._get_tile_name()
        self._collection = self._set_collection()
        if self._collection == LandsatCollection.COL_1:
            self._quality_id = &#34;_BQA&#34;
            self._nodata_band_id = &#34;_BQA&#34;
            self.needs_extraction = True  # Too slow to read directly tar.gz files
        else:
            self._quality_id = &#34;_QA_RADSAT&#34;
            self._nodata_band_id = &#34;_QA_PIXEL&#34;
            self.needs_extraction = False  # Fine to read .tar files

        # Post init done by the super class
        super()._post_init()

    def _get_path(self, band_id: str) -&gt; str:
        &#34;&#34;&#34;
        Get either the archived path of the normal path of a tif file

        Args:
            band_id (str): Band ID

        Returns:
            str: band path

        &#34;&#34;&#34;
        if self.is_archived:
            # Because of gap_mask files that have the same name structure and exists only for L7
            if self.product_type == LandsatProductType.L1_ETM:
                regex = f&#34;.*RT{band_id}.*&#34;
            else:
                regex = f&#34;.*{band_id}.*&#34;
            path = files.get_archived_rio_path(self.path, regex)
        else:
            path = files.get_file_in_dir(self.path, band_id, extension=&#34;TIF&#34;)

        return path

    def footprint(self) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;
        Get real footprint of the products (without nodata, in french == emprise utile)

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;LC08_L1GT_023030_20200518_20200527_01_T2&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.footprint()
           index                                           geometry
        0      0  POLYGON ((366165.000 4899735.000, 366165.000 4...
        ```

        Overload of the generic function because landsat nodata seems to be different in QA than in regular bands.
        Indeed, nodata pixels vary according to the band sensor footprint,
        whereas QA nodata is where at least one band has nodata.

        We chose to keep QA nodata values for the footprint in order to show where all bands are valid.

        **TL;DR: We use the QA nodata value to determine the product&#39;s footprint**.

        Returns:
            gpd.GeoDataFrame: Footprint as a GeoDataFrame
        &#34;&#34;&#34;
        nodata_band = self._get_path(self._nodata_band_id)

        # Vectorize the nodata band
        nodata = rasters.vectorize(nodata_band, values=1)

        # Clip the extent with the nodata
        footprint = gpd.overlay(self.extent(), nodata, how=&#34;symmetric_difference&#34;)

        return footprint

    def _get_tile_name(self) -&gt; str:
        &#34;&#34;&#34;
        Retrieve tile name

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;LC08_L1GT_023030_20200518_20200527_01_T2&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_tile_name()
        &#39;023030&#39;
        ```

        Returns:
            str: Tile name
        &#34;&#34;&#34;
        return self.split_name[2]

    @abstractmethod
    def _set_product_type(self) -&gt; None:
        &#34;&#34;&#34;Get products type&#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _set_mss_product_type(self, version: int) -&gt; None:
        &#34;&#34;&#34;Set MSS product type and map corresponding bands&#34;&#34;&#34;
        if &#34;L1&#34; in self.name:
            self.product_type = LandsatProductType.L1_MSS
            self.band_names.map_bands(
                {
                    obn.GREEN: &#34;4&#34; if version &lt; 4 else &#34;1&#34;,
                    obn.RED: &#34;5&#34; if version &lt; 4 else &#34;2&#34;,
                    obn.VRE_1: &#34;6&#34; if version &lt; 4 else &#34;3&#34;,
                    obn.VRE_2: &#34;6&#34; if version &lt; 4 else &#34;3&#34;,
                    obn.VRE_3: &#34;6&#34; if version &lt; 4 else &#34;3&#34;,
                    obn.NIR: &#34;7&#34; if version &lt; 4 else &#34;4&#34;,
                    obn.NARROW_NIR: &#34;7&#34; if version &lt; 4 else &#34;4&#34;,
                }
            )
        else:
            raise InvalidProductError(&#34;Only Landsat level 1 are managed in EOReader&#34;)

    def _set_tm_product_type(self) -&gt; None:
        &#34;&#34;&#34;Set TM product type and map corresponding bands&#34;&#34;&#34;
        if &#34;L1&#34; in self.name:
            self.product_type = LandsatProductType.L1_TM
            self.band_names.map_bands(
                {
                    obn.BLUE: &#34;1&#34;,
                    obn.GREEN: &#34;2&#34;,
                    obn.RED: &#34;3&#34;,
                    obn.NIR: &#34;4&#34;,
                    obn.NARROW_NIR: &#34;4&#34;,
                    obn.SWIR_1: &#34;5&#34;,
                    obn.SWIR_2: &#34;7&#34;,
                    obn.TIR_1: &#34;6&#34;,
                    obn.TIR_2: &#34;6&#34;,
                }
            )
        else:
            raise InvalidProductError(&#34;Only Landsat level 1 are managed in EOReader&#34;)

    def _set_etm_product_type(self) -&gt; None:
        &#34;&#34;&#34;Set ETM product type and map corresponding bands&#34;&#34;&#34;
        if &#34;L1&#34; in self.name:
            self.product_type = LandsatProductType.L1_ETM
            self.band_names.map_bands(
                {
                    obn.BLUE: &#34;1&#34;,
                    obn.GREEN: &#34;2&#34;,
                    obn.RED: &#34;3&#34;,
                    obn.NIR: &#34;4&#34;,
                    obn.NARROW_NIR: &#34;4&#34;,
                    obn.SWIR_1: &#34;5&#34;,
                    obn.SWIR_2: &#34;7&#34;,
                    obn.PAN: &#34;8&#34;,
                    obn.TIR_1: &#34;6_VCID_1&#34;,
                    obn.TIR_2: &#34;6_VCID_2&#34;,
                }
            )
        else:
            raise InvalidProductError(&#34;Only Landsat level 1 are managed in EOReader&#34;)

    def _set_olci_product_type(self) -&gt; None:
        &#34;&#34;&#34;Set OLCI product type and map corresponding bands&#34;&#34;&#34;
        if &#34;L1&#34; in self.name:
            self.product_type = LandsatProductType.L1_OLCI
            self.band_names.map_bands(
                {
                    obn.CA: &#34;1&#34;,
                    obn.BLUE: &#34;2&#34;,
                    obn.GREEN: &#34;3&#34;,
                    obn.RED: &#34;4&#34;,
                    obn.NIR: &#34;5&#34;,
                    obn.NARROW_NIR: &#34;5&#34;,
                    obn.SWIR_1: &#34;6&#34;,
                    obn.SWIR_2: &#34;7&#34;,
                    obn.PAN: &#34;8&#34;,
                    obn.SWIR_CIRRUS: &#34;9&#34;,
                    obn.TIR_1: &#34;10&#34;,
                    obn.TIR_2: &#34;11&#34;,
                }
            )
        else:
            raise InvalidProductError(&#34;Only Landsat level 1 are managed in EOReader&#34;)

    def get_datetime(self, as_datetime: bool = False) -&gt; Union[str, datetime]:
        &#34;&#34;&#34;
        Get the product&#39;s acquisition datetime, with format `YYYYMMDDTHHMMSS` &lt;-&gt; `%Y%m%dT%H%M%S`

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;LC08_L1GT_023030_20200518_20200527_01_T2&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_datetime(as_datetime=True)
        datetime.datetime(2020, 5, 18, 16, 34, 7)
        &gt;&gt;&gt; prod.get_datetime(as_datetime=False)
        &#39;20200518T163407&#39;
        ```

        Args:
            as_datetime (bool): Return the date as a datetime.datetime. If false, returns a string.

        Returns:
             Union[str, datetime.datetime]: Its acquisition datetime
        &#34;&#34;&#34;
        try:
            mtd = self.read_mtd(force_pd=True)
            date = mtd[&#34;DATE_ACQUIRED&#34;].value  # 1982-09-06
            # &#34;16:47:09.5990000Z&#34;: needs max 6 digits for ms
            hours = mtd[&#34;SCENE_CENTER_TIME&#34;].value.replace(&#39;&#34;&#39;, &#34;&#34;)[:-3]

            date = (
                f&#34;{datetime.strptime(date, &#39;%Y-%m-%d&#39;).strftime(&#39;%Y%m%d&#39;)}&#34;
                f&#34;T{datetime.strptime(hours, &#39;%H:%M:%S.%f&#39;).strftime(&#39;%H%M%S&#39;)}&#34;
            )
        except (FileNotFoundError, KeyError):
            date = datetime.strptime(self.split_name[3], &#34;%Y%m%d&#34;).strftime(
                DATETIME_FMT
            )

        if as_datetime:
            date = datetime.strptime(date, DATETIME_FMT)

        return date

    def get_band_paths(self, band_list: list, resolution: float = None) -&gt; dict:
        &#34;&#34;&#34;
        Return the paths of required bands.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
        {
            &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;:
                &#39;LC08_L1GT_023030_20200518_20200527_01_T2\\LC08_L1GT_023030_20200518_20200527_01_T2_B3.TIF&#39;,
            &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;:
                &#39;LC08_L1GT_023030_20200518_20200527_01_T2\\LC08_L1GT_023030_20200518_20200527_01_T2_B4.TIF&#39;
        }

        ```

        Args:
            band_list (list): List of the wanted bands
            resolution (float): Useless here

        Returns:
            dict: Dictionary containing the path of each queried band
        &#34;&#34;&#34;
        band_paths = {}
        for band in band_list:
            if not self.has_band(band):
                raise InvalidProductError(
                    f&#34;Non existing band ({band.name}) &#34;
                    f&#34;for Landsat-{self.product_type.name} products&#34;
                )
            band_nb = self.band_names[band]

            try:
                band_paths[band] = self._get_path(f&#34;_B{band_nb}&#34;)
            except FileNotFoundError as ex:
                raise InvalidProductError(
                    f&#34;Non existing {band} ({band_nb}) band for {self.path}&#34;
                ) from ex

        return band_paths

    def read_mtd(
        self, force_pd=False
    ) -&gt; Union[pd.DataFrame, Tuple[etree._Element, str]]:
        &#34;&#34;&#34;
        Read Landsat metadata as:

         - a `pandas.DataFrame` whatever its collection is (by default for collection 1)
         - a XML root + its namespace if the product is retrieved from the 2nd collection (by default for collection 2)

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;LC08_L1GT_023030_20200518_20200527_01_T2&#34;
        &gt;&gt;&gt; prod = Reader().open(path)

        &gt;&gt;&gt; # COLLECTION 1 : Open metadata as panda DataFrame
        &gt;&gt;&gt; prod.read_mtd()
        NAME                                           ORIGIN  ...    RESAMPLING_OPTION
        value  &#34;Image courtesy of the U.S. Geological Survey&#34;  ...  &#34;CUBIC_CONVOLUTION&#34;
        [1 rows x 197 columns]

        &gt;&gt;&gt; # COLLECTION 2 : Open metadata as XML
        &gt;&gt;&gt; path = r&#34;LC08_L1TP_200030_20201220_20210310_02_T1&#34;  # Collection 2
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.read_mtd()
        (&lt;Element LANDSAT_METADATA_FILE at 0x19229016048&gt;, &#39;&#39;)

        &gt;&gt;&gt; # COLLECTION 2 : Force to pandas.DataFrame
        &gt;&gt;&gt; prod.read_mtd(force_pd=True)
        NAME                                           ORIGIN  ...    RESAMPLING_OPTION
        value  &#34;Image courtesy of the U.S. Geological Survey&#34;  ...  &#34;CUBIC_CONVOLUTION&#34;
        [1 rows x 263 columns]
        ```
        Args:
            force_pd (bool): If collection 2, return a pandas.DataFrame instead of a XML root + namespace
        Returns:
            pd.DataFrame: Metadata as a Pandas DataFrame
        &#34;&#34;&#34;
        # WARNING: always use force_pd in this class !
        as_pd = (self._collection == LandsatCollection.COL_1) or force_pd

        if as_pd:
            mtd_name = f&#34;{self.name}_MTL.txt&#34;
            if self.is_archived:
                # We need to extract the file in memry to be used with pandas
                tar_ds = tarfile.open(self.path, &#34;r&#34;)
                info = [f.name for f in tar_ds.getmembers() if mtd_name in f.name][0]
                mtd_path = tar_ds.extractfile(info)
            else:
                # FOR COLLECTION 1 AND 2
                tar_ds = None
                mtd_path = os.path.join(self.path, mtd_name)

                if not os.path.isfile(mtd_path):
                    raise FileNotFoundError(
                        f&#34;Unable to find the metadata file associated with {self.path}&#34;
                    )

            # Parse
            mtd_data = pd.read_table(
                mtd_path,
                sep=&#34;\s=\s&#34;,
                names=[&#34;NAME&#34;, &#34;value&#34;],
                skipinitialspace=True,
                engine=&#34;python&#34;,
            )

            # Workaround an unexpected behaviour in pandas !
            if any(mtd_data.NAME == &#34;=&#34;):
                mtd_data = pd.read_table(
                    mtd_path,
                    sep=&#34;=&#34;,
                    names=[&#34;NAME&#34;, &#34;=&#34;, &#34;value&#34;],
                    usecols=[0, 2],
                    skipinitialspace=True,
                )

            # Remove useless rows
            mtd_data = mtd_data[~mtd_data[&#34;NAME&#34;].isin([&#34;GROUP&#34;, &#34;END_GROUP&#34;, &#34;END&#34;])]

            # Set index
            mtd_data = mtd_data.set_index(&#34;NAME&#34;).T

            # Close if needed
            if tar_ds:
                tar_ds.close()
        else:
            if self.is_archived:
                root = files.read_archived_xml(self.path, f&#34;.*{self.name}_MTL.xml&#34;)
            else:
                # ONLY FOR COLLECTION 2
                try:
                    mtd_file = glob.glob(
                        os.path.join(self.path, f&#34;{self.name}_MTL.xml&#34;)
                    )[0]

                    # pylint: disable=I1101:
                    # Module &#39;lxml.etree&#39; has no &#39;parse&#39; member, but source is unavailable.
                    xml_tree = etree.parse(mtd_file)
                    root = xml_tree.getroot()
                except IndexError as ex:
                    raise InvalidProductError(
                        f&#34;Metadata file ({self.name}.xml) not found in {self.path}&#34;
                    ) from ex

            # Get namespace
            namespace = &#34;&#34;  # No namespace here

            mtd_data = (root, namespace)

        return mtd_data

    def _read_band(
        self,
        path: str,
        resolution: Union[tuple, list, float] = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Read band from a dataset.

        .. WARNING::
            Invalid pixels are not managed here !

        Args:
            path (str): Band path
            resolution (Union[tuple, list, float]): Resolution of the wanted band, in dataset resolution unit (X, Y)
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            XDS_TYPE: Radiometrically coherent band, saved as float 32 and its metadata

        &#34;&#34;&#34;
        # Get band name: the last number of the filename:
        # ie: &#39;LC08_L1TP_200030_20191218_20191226_01_T1_B1&#39;
        if self.is_archived:
            filename = files.get_filename(path.split(&#34;!&#34;)[-1])
        else:
            filename = files.get_filename(path)

        band_name = filename[-1]
        if self._quality_id in filename or self._nodata_band_id in filename:
            band = rasters.read(
                path,
                resolution=resolution,
                size=size,
                resampling=Resampling.nearest,  # NEAREST TO KEEP THE FLAGS
                masked=False,
            ).astype(np.uint16)
        else:
            # Read band (call superclass generic method)
            band = rasters.read(
                path, resolution=resolution, size=size, resampling=Resampling.bilinear
            ).astype(np.float32)

            # Open mtd
            mtd_data = self.read_mtd(force_pd=True)

            # Get band nb and corresponding coeff
            c_mul_str = &#34;REFLECTANCE_MULT_BAND_&#34; + band_name
            c_add_str = &#34;REFLECTANCE_ADD_BAND_&#34; + band_name

            # Get coeffs to convert DN to reflectance
            c_mul = mtd_data[c_mul_str].value
            c_add = mtd_data[c_add_str].value

            # Manage NULL values
            try:
                c_mul = float(c_mul)
            except ValueError:
                c_mul = 1
            try:
                c_add = float(c_add)
            except ValueError:
                c_add = 0

            # Compute the correct radiometry of the band and set no data to 0
            band = c_mul * band + c_add  # Already in float

        return band

    # pylint: disable=R0913
    # R0913: Too many arguments (6/5) (too-many-arguments)
    def _manage_invalid_pixels(
        self,
        band_arr: XDS_TYPE,
        band: obn,
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Manage invalid pixels (Nodata, saturated, defective...)

        Args:
            band_arr (XDS_TYPE): Band array
            band (obn): Band name as an OpticalBandNames
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            XDS_TYPE: Cleaned band array
        &#34;&#34;&#34;
        # Open QA band
        landsat_qa_path = self._get_path(self._quality_id)
        qa_arr = self._read_band(
            landsat_qa_path, resolution=resolution, size=size
        ).data  # To np array

        if self._collection == LandsatCollection.COL_1:
            # https://www.usgs.gov/core-science-systems/nli/landsat/landsat-collection-1-level-1-quality-assessment-band
            # Bit ids
            nodata_id = 0  # Fill value
            dropped_id = 1  # Dropped pixel or terrain occlusion
            # Set nodata to every saturated pixel, even if only 1-2 bands are touched by it
            # -&gt; 01 or 10 or 11
            # -&gt; bit 2 or bit 3
            sat_id_1 = 2
            sat_id_2 = 3
            nodata, dropped, sat_1, sat_2 = rasters.read_bit_array(
                qa_arr, [nodata_id, dropped_id, sat_id_1, sat_id_2]
            )
            mask = nodata | dropped | sat_1 | sat_2
        else:
            # https://www.usgs.gov/core-science-systems/nli/landsat/landsat-collection-2-quality-assessment-bands
            # SATURATED &amp; OTHER PIXELS
            band_nb = int(self.band_names[band])

            # Bit ids
            sat_id = band_nb - 1  # Saturated pixel
            if self.product_type != LandsatProductType.L1_OLCI:
                other_id = 11  # Terrain occlusion
            else:
                other_id = 9  # Dropped pixels

            sat, other = rasters.read_bit_array(qa_arr, [sat_id, other_id])

            # If collection 2, nodata has to be found in pixel QA file
            landsat_stat_path = self._get_path(self._nodata_band_id)
            pixel_arr = self._read_band(
                landsat_stat_path, resolution=resolution, size=size
            ).data
            nodata = np.where(pixel_arr == 1, 1, 0)

            mask = sat | other | nodata

        return self._set_nodata_mask(band_arr, mask)

    def _load_bands(
        self,
        band_list: Union[list, BandNames],
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load bands as numpy arrays with the same resolution (and same metadata).

        Args:
            band_list (list, BandNames): List of the wanted bands
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        # Return empty if no band are specified
        if not band_list:
            return {}

        # Get band paths
        if not isinstance(band_list, list):
            band_list = [band_list]
        band_paths = self.get_band_paths(band_list)

        # Open bands and get array (resampled if needed)
        band_arrays = self._open_bands(band_paths, resolution=resolution, size=size)

        return band_arrays

    def get_mean_sun_angles(self) -&gt; (float, float):
        &#34;&#34;&#34;
        Get Mean Sun angles (Azimuth and Zenith angles)

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;LC08_L1GT_023030_20200518_20200527_01_T2.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_mean_sun_angles()
        (140.80752656, 61.93065805)
        ```

        Returns:
            (float, float): Mean Azimuth and Zenith angle
        &#34;&#34;&#34;
        # Retrieve angles
        mtd_data = self.read_mtd(force_pd=True)
        azimuth_angle = float(mtd_data.SUN_AZIMUTH.value)
        zenith_angle = float(mtd_data.SUN_ELEVATION.value)

        return azimuth_angle, zenith_angle

    @abstractmethod
    def _get_condensed_name(self) -&gt; str:
        &#34;&#34;&#34;
        Get products condensed name ({date}_Lx_{tile}_{product_type}).

        Returns:
            str: Condensed Landsat name
        &#34;&#34;&#34;
        return f&#34;{self.get_datetime()}_{self.platform.name}_{self.tile_name}_{self.product_type.value}&#34;

    def _has_cloud_band(self, band: BandNames) -&gt; bool:
        &#34;&#34;&#34;
        Does this products has the specified cloud band ?

        - (COL 1)[https://www.usgs.gov/land-resources/nli/landsat/landsat-collection-1-level-1-quality-assessment-band]
        - (COL 2)[https://www.usgs.gov/core-science-systems/nli/landsat/landsat-collection-2-quality-assessment-bands]
        True
        ```
        &#34;&#34;&#34;
        if self.product_type == LandsatProductType.L1_OLCI:
            has_band = True
        elif self.product_type in [LandsatProductType.L1_ETM, LandsatProductType.L1_TM]:
            has_band = self._e_tm_has_cloud_band(band)
        elif self.product_type == LandsatProductType.L1_MSS:
            has_band = self._mss_has_cloud_band(band)
        else:
            raise InvalidProductError(f&#34;Invalid product type: {self.product_type}&#34;)

        return has_band

    @staticmethod
    def _mss_has_cloud_band(band: BandNames) -&gt; bool:
        &#34;&#34;&#34;
        Does this products has the specified cloud band ?
        ```
        &#34;&#34;&#34;
        if band in [RAW_CLOUDS, CLOUDS, ALL_CLOUDS]:
            has_band = True
        else:
            has_band = False
        return has_band

    @staticmethod
    def _e_tm_has_cloud_band(band: BandNames) -&gt; bool:
        &#34;&#34;&#34;
        Does this products has the specified cloud band ?
        ```
        &#34;&#34;&#34;
        if band in [RAW_CLOUDS, CLOUDS, ALL_CLOUDS, SHADOWS]:
            has_band = True
        else:
            has_band = False
        return has_band

    def _load_clouds(
        self, bands: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load cloud files as numpy arrays with the same resolution (and same metadata).

        Read Landsat clouds from QA mask.
        See here for clouds_values:

        - (COL 1)[https://www.usgs.gov/land-resources/nli/landsat/landsat-collection-1-level-1-quality-assessment-band]
        - (COL 2)[https://www.usgs.gov/core-science-systems/nli/landsat/landsat-collection-2-quality-assessment-bands]


        Args:
            bands (list): List of the wanted bands
            resolution (int): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        band_dict = {}

        if bands:
            # Open QA band
            landsat_qa_path = self._get_path(self._quality_id)
            qa_arr = self._read_band(landsat_qa_path, resolution=resolution, size=size)

            if self.product_type == LandsatProductType.L1_OLCI:
                band_dict = self._load_olci_clouds(qa_arr, bands)
            elif self.product_type in [
                LandsatProductType.L1_ETM,
                LandsatProductType.L1_TM,
            ]:
                band_dict = self._load_e_tm_clouds(qa_arr, bands)
            elif self.product_type == LandsatProductType.L1_MSS:
                band_dict = self._load_mss_clouds(qa_arr, bands)
            else:
                raise InvalidProductError(f&#34;Invalid product type: {self.product_type}&#34;)

        return band_dict

    def _load_mss_clouds(self, qa_arr: XDS_TYPE, band_list: list) -&gt; dict:
        &#34;&#34;&#34;
        Load cloud files as numpy arrays with the same resolution (and same metadata).

        Read Landsat-MSS clouds from QA mask.
        See here for clouds_values:

        - (COL 1)[https://www.usgs.gov/land-resources/nli/landsat/landsat-collection-1-level-1-quality-assessment-band]
        - (COL 2)[https://www.usgs.gov/media/files/landsat-1-5-mss-collection-2-level-1-data-format-control-book]


        Args:
            qa_arr (XDS_TYPE): Quality array
            band_list (list): List of the wanted bands
        Returns:
            dict, dict: Dictionary {band_name, band_array}
        &#34;&#34;&#34;
        bands = {}

        # Get clouds and nodata
        nodata_id = 0
        cloud_id = (
            4 if self._collection == LandsatCollection.COL_1 else 3
        )  # Clouds with high confidence

        clouds = None
        if ALL_CLOUDS in band_list or CLOUDS in band_list:
            nodata, cld = rasters.read_bit_array(qa_arr, [nodata_id, cloud_id])
            clouds = self._create_mask(qa_arr, cld, nodata)

        for band in band_list:
            if band == ALL_CLOUDS:
                bands[band] = clouds
            elif band == CLOUDS:
                bands[band] = clouds
            elif band == RAW_CLOUDS:
                bands[band] = qa_arr
            else:
                raise InvalidTypeError(
                    f&#34;Non existing cloud band for Landsat-MSS sensor: {band}&#34;
                )

        return bands

    def _load_e_tm_clouds(
        self, qa_arr: XDS_TYPE, band_list: Union[list, BandNames]
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load cloud files as numpy arrays with the same resolution (and same metadata).

        Read Landsat-(E)TM clouds from QA mask.
        See here for clouds_values:

        - (COL 1)[https://www.usgs.gov/land-resources/nli/landsat/landsat-collection-1-level-1-quality-assessment-band]
        - (COL 2 TM)[https://www.usgs.gov/media/files/landsat-4-5-tm-collection-2-level-1-data-format-control-book]
        - (COL 2 ETM)[https://www.usgs.gov/media/files/landsat-7-etm-collection-2-level-1-data-format-control-book]


        Args:
            qa_arr (XDS_TYPE): Quality array
            band_list (list): List of the wanted bands
        Returns:
            dict, dict: Dictionary {band_name, band_array}
        &#34;&#34;&#34;
        bands = {}

        # Get clouds and nodata
        nodata = None
        cld = None
        shd = None
        if any(band in [ALL_CLOUDS, CLOUDS, SHADOWS] for band in band_list):
            if self._collection == LandsatCollection.COL_1:
                # Bit id
                nodata_id = 0
                cloud_id = 4  # Clouds with high confidence
                shd_conf_1_id = 7
                shd_conf_2_id = 8
                nodata, cld, shd_conf_1, shd_conf_2 = rasters.read_bit_array(
                    qa_arr, [nodata_id, cloud_id, shd_conf_1_id, shd_conf_2_id]
                )
                shd = shd_conf_1 &amp; shd_conf_2
            else:
                # Bit ids
                nodata_id = 0
                cloud_id = 3  # Clouds with high confidence
                shd_id = 4  # Shadows with high confidence
                nodata, cld, shd = rasters.read_bit_array(
                    qa_arr, [nodata_id, cloud_id, shd_id]
                )

        for band in band_list:
            if band == ALL_CLOUDS:
                bands[band] = self._create_mask(qa_arr, cld | shd, nodata)
            elif band == SHADOWS:
                bands[band] = self._create_mask(qa_arr, shd, nodata)
            elif band == CLOUDS:
                bands[band] = self._create_mask(qa_arr, cld, nodata)
            elif band == RAW_CLOUDS:
                bands[band] = qa_arr
            else:
                raise InvalidTypeError(
                    f&#34;Non existing cloud band for Landsat-(E)TM sensor: {band}&#34;
                )

        return bands

    def _load_olci_clouds(
        self, qa_arr: XDS_TYPE, band_list: Union[list, BandNames]
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load cloud files as numpy arrays with the same resolution (and same metadata).

        Read Landsat-OLCI clouds from QA mask.
        See here for clouds_values:

        - (COL 1)[https://www.usgs.gov/land-resources/nli/landsat/landsat-collection-1-level-1-quality-assessment-band]
        - (COL 2)[https://www.usgs.gov/media/files/landsat-8-level-1-data-format-control-book]


        Args:
            qa_arr (XDS_TYPE): Quality array
            band_list (list): List of the wanted bands
        Returns:
            dict, dict: Dictionary {band_name, band_array}
        &#34;&#34;&#34;
        bands = {}

        # Get clouds and nodata
        nodata = None
        cld = None
        shd = None
        cir = None
        if any(band in [ALL_CLOUDS, CLOUDS, SHADOWS] for band in band_list):
            if self._collection == LandsatCollection.COL_1:
                # Bit ids
                nodata_id = 0
                cloud_id = 4  # Clouds with high confidence
                shd_conf_1_id = 7
                shd_conf_2_id = 8
                cir_conf_1_id = 11
                cir_conf_2_id = 12

                # Read binary mask
                (
                    nodata,
                    cld,
                    shd_conf_1,
                    shd_conf_2,
                    cir_conf_1,
                    cir_conf_2,
                ) = rasters.read_bit_array(
                    qa_arr,
                    [
                        nodata_id,
                        cloud_id,
                        shd_conf_1_id,
                        shd_conf_2_id,
                        cir_conf_1_id,
                        cir_conf_2_id,
                    ],
                )

                shd = shd_conf_1 &amp; shd_conf_2
                cir = cir_conf_1 &amp; cir_conf_2
            else:
                # Bit ids
                nodata_id = 0
                cloud_id = 3  # Clouds with high confidence
                shd_id = 4  # Shadows with high confidence
                cir_id = 2  # Cirrus with high confidence
                nodata, cld, shd, cir = rasters.read_bit_array(
                    qa_arr, [nodata_id, cloud_id, shd_id, cir_id]
                )

        for band in band_list:
            if band == ALL_CLOUDS:
                bands[band] = self._create_mask(qa_arr, cld | shd | cir, nodata)
            elif band == SHADOWS:
                bands[band] = self._create_mask(qa_arr, shd, nodata)
            elif band == CLOUDS:
                bands[band] = self._create_mask(qa_arr, cld, nodata)
            elif band == CIRRUS:
                bands[band] = self._create_mask(qa_arr, cir, nodata)
            elif band == RAW_CLOUDS:
                bands[band] = qa_arr
            else:
                raise InvalidTypeError(
                    f&#34;Non existing cloud band for Landsat-OLCI sensor: {band}&#34;
                )

        return bands</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></li>
<li><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="eoreader.products.optical.l1_product.L1Product" href="l1_product.html#eoreader.products.optical.l1_product.L1Product">L1Product</a></li>
<li><a title="eoreader.products.optical.l2_product.L2Product" href="l2_product.html#eoreader.products.optical.l2_product.L2Product">L2Product</a></li>
<li><a title="eoreader.products.optical.l3_product.L3Product" href="l3_product.html#eoreader.products.optical.l3_product.L3Product">L3Product</a></li>
<li><a title="eoreader.products.optical.l4_product.L4Product" href="l4_product.html#eoreader.products.optical.l4_product.L4Product">L4Product</a></li>
<li><a title="eoreader.products.optical.l5_product.L5Product" href="l5_product.html#eoreader.products.optical.l5_product.L5Product">L5Product</a></li>
<li><a title="eoreader.products.optical.l7_product.L7Product" href="l7_product.html#eoreader.products.optical.l7_product.L7Product">L7Product</a></li>
<li><a title="eoreader.products.optical.l8_product.L8Product" href="l8_product.html#eoreader.products.optical.l8_product.L8Product">L8Product</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.output"><code class="name">var <span class="ident">output</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.output" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.output">output</a></code>
</p>
<div class="desc inherited"><p>Output directory of the product, to write orthorectified data for example.</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.name"><code class="name">var <span class="ident">name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.name">name</a></code>
</p>
<div class="desc inherited"><p>Product name (its filename without any extension).</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.split_name"><code class="name">var <span class="ident">split_name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.split_name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.split_name">split_name</a></code>
</p>
<div class="desc inherited"><p>Split name, to retrieve every information from its filename (dates, tile, product type&hellip;).</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.archive_path"><code class="name">var <span class="ident">archive_path</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.archive_path" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.archive_path">archive_path</a></code>
</p>
<div class="desc inherited"><p>Archive path, same as the product path if not specified.
Useful when you want to know where both the extracted and archived version of your product </p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.path"><code class="name">var <span class="ident">path</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.path" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.path">path</a></code>
</p>
<div class="desc inherited"><p>Usable path to the product, either extracted or archived path, according to the satellite.</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.is_archived"><code class="name">var <span class="ident">is_archived</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.is_archived" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.is_archived">is_archived</a></code>
</p>
<div class="desc inherited"><p>Is the archived product is processed
(a products is considered as archived if its products path is a directory).</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.needs_extraction"><code class="name">var <span class="ident">needs_extraction</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.needs_extraction" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.needs_extraction">needs_extraction</a></code>
</p>
<div class="desc inherited"><p>Does this products needs to be extracted to be processed ? (<code>True</code> by default).</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.date"><code class="name">var <span class="ident">date</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.date" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.date">date</a></code>
</p>
<div class="desc inherited"><p>Acquisition date.</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.datetime"><code class="name">var <span class="ident">datetime</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.datetime" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.datetime">datetime</a></code>
</p>
<div class="desc inherited"><p>Acquisition datetime.</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.tile_name"><code class="name">var <span class="ident">tile_name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.tile_name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.tile_name">tile_name</a></code>
</p>
<div class="desc inherited"><p>Tile if possible (for data that can be piled, for example S2 and Landsats).</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.sensor_type"><code class="name">var <span class="ident">sensor_type</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.sensor_type" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.sensor_type">sensor_type</a></code>
</p>
<div class="desc inherited"><p>Sensor type, SAR or optical.</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.product_type"><code class="name">var <span class="ident">product_type</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.product_type" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.product_type">product_type</a></code>
</p>
<div class="desc inherited"><p>Product type, satellite-related field, such as L1C or L2A for Sentinel-2 data.</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.band_names"><code class="name">var <span class="ident">band_names</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.band_names" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.band_names">band_names</a></code>
</p>
<div class="desc inherited"><p>Band mapping between band wrapping names such as <code>GREEN</code> and band real number such as <code>03</code> for Sentinel-2.</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.is_reference"><code class="name">var <span class="ident">is_reference</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.is_reference" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.is_reference">is_reference</a></code>
</p>
<div class="desc inherited"><p>If the product is a reference, used for algorithms that need pre and post data, such as fire detection.</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.corresponding_ref"><code class="name">var <span class="ident">corresponding_ref</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.corresponding_ref" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.corresponding_ref">corresponding_ref</a></code>
</p>
<div class="desc inherited"><p>The corresponding reference products to the current one
(if the product is not a reference but has a reference data corresponding to it).
A list </p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.nodata"><code class="name">var <span class="ident">nodata</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.nodata" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.nodata">nodata</a></code>
</p>
<div class="desc inherited"><p>Product nodata, set to 0 by default. Please do not touch this or all index will fail.</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.platform"><code class="name">var <span class="ident">platform</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.platform" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.platform">platform</a></code>
</p>
<div class="desc inherited"><p>Product platform, such as Sentinel-2</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.resolution"><code class="name">var <span class="ident">resolution</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.resolution" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.resolution">resolution</a></code>
</p>
<div class="desc inherited"><p>Default resolution in meters of the current product.
For SAR product, we use Ground Range resolution as we will automatically orthorectify the tiles.</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.condensed_name"><code class="name">var <span class="ident">condensed_name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.condensed_name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.condensed_name">condensed_name</a></code>
</p>
<div class="desc inherited"><p>Condensed name, the filename with only useful data to keep the name unique
(ie. <code>20191215T110441_S2_30TXP_L2A_122756</code>).
Used to shorten names and paths.</p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.sat_id"><code class="name">var <span class="ident">sat_id</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.sat_id" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.sat_id">sat_id</a></code>
</p>
<div class="desc inherited"><p>Satellite ID, i.e. <code>S2</code> for Sentinel-2</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.footprint"><code class="name flex">
<p>def <span class="ident">footprint</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Get real footprint of the products (without nodata, in french == emprise utile)</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;LC08_L1GT_023030_20200518_20200527_01_T2&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.footprint()
   index                                           geometry
0      0  POLYGON ((366165.000 4899735.000, 366165.000 4...
</code></pre>
<p>Overload of the generic function because landsat nodata seems to be different in QA than in regular bands.
Indeed, nodata pixels vary according to the band sensor footprint,
whereas QA nodata is where at least one band has nodata.</p>
<p>We chose to keep QA nodata values for the footprint in order to show where all bands are valid.</p>
<p><strong>TL;DR: We use the QA nodata value to determine the product's footprint</strong>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>Footprint as a GeoDataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def footprint(self) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get real footprint of the products (without nodata, in french == emprise utile)

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;LC08_L1GT_023030_20200518_20200527_01_T2&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.footprint()
       index                                           geometry
    0      0  POLYGON ((366165.000 4899735.000, 366165.000 4...
    ```

    Overload of the generic function because landsat nodata seems to be different in QA than in regular bands.
    Indeed, nodata pixels vary according to the band sensor footprint,
    whereas QA nodata is where at least one band has nodata.

    We chose to keep QA nodata values for the footprint in order to show where all bands are valid.

    **TL;DR: We use the QA nodata value to determine the product&#39;s footprint**.

    Returns:
        gpd.GeoDataFrame: Footprint as a GeoDataFrame
    &#34;&#34;&#34;
    nodata_band = self._get_path(self._nodata_band_id)

    # Vectorize the nodata band
    nodata = rasters.vectorize(nodata_band, values=1)

    # Clip the extent with the nodata
    footprint = gpd.overlay(self.extent(), nodata, how=&#34;symmetric_difference&#34;)

    return footprint</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.get_datetime"><code class="name flex">
<p>def <span class="ident">get_datetime</span>(</p><p>self, <br>as_datetime=False)</p>
</code></dt>
<dd>
<div class="desc"><p>Get the product's acquisition datetime, with format <code>YYYYMMDDTHHMMSS</code> &lt;-&gt; <code>%Y%m%dT%H%M%S</code></p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;LC08_L1GT_023030_20200518_20200527_01_T2&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_datetime(as_datetime=True)
datetime.datetime(2020, 5, 18, 16, 34, 7)
&gt;&gt;&gt; prod.get_datetime(as_datetime=False)
'20200518T163407'
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>as_datetime</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return the date as a datetime.datetime. If false, returns a string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, datetime.datetime]</code></dt>
<dd>Its acquisition datetime</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_datetime(self, as_datetime: bool = False) -&gt; Union[str, datetime]:
    &#34;&#34;&#34;
    Get the product&#39;s acquisition datetime, with format `YYYYMMDDTHHMMSS` &lt;-&gt; `%Y%m%dT%H%M%S`

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;LC08_L1GT_023030_20200518_20200527_01_T2&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_datetime(as_datetime=True)
    datetime.datetime(2020, 5, 18, 16, 34, 7)
    &gt;&gt;&gt; prod.get_datetime(as_datetime=False)
    &#39;20200518T163407&#39;
    ```

    Args:
        as_datetime (bool): Return the date as a datetime.datetime. If false, returns a string.

    Returns:
         Union[str, datetime.datetime]: Its acquisition datetime
    &#34;&#34;&#34;
    try:
        mtd = self.read_mtd(force_pd=True)
        date = mtd[&#34;DATE_ACQUIRED&#34;].value  # 1982-09-06
        # &#34;16:47:09.5990000Z&#34;: needs max 6 digits for ms
        hours = mtd[&#34;SCENE_CENTER_TIME&#34;].value.replace(&#39;&#34;&#39;, &#34;&#34;)[:-3]

        date = (
            f&#34;{datetime.strptime(date, &#39;%Y-%m-%d&#39;).strftime(&#39;%Y%m%d&#39;)}&#34;
            f&#34;T{datetime.strptime(hours, &#39;%H:%M:%S.%f&#39;).strftime(&#39;%H%M%S&#39;)}&#34;
        )
    except (FileNotFoundError, KeyError):
        date = datetime.strptime(self.split_name[3], &#34;%Y%m%d&#34;).strftime(
            DATETIME_FMT
        )

    if as_datetime:
        date = datetime.strptime(date, DATETIME_FMT)

    return date</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.get_band_paths"><code class="name flex">
<p>def <span class="ident">get_band_paths</span>(</p><p>self, <br>band_list, <br>resolution=None)</p>
</code></dt>
<dd>
<div class="desc"><p>Return the paths of required bands.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; from eoreader.bands.alias import *
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
{
    &lt;OpticalBandNames.GREEN: 'GREEN'&gt;:
        'LC08_L1GT_023030_20200518_20200527_01_T2\LC08_L1GT_023030_20200518_20200527_01_T2_B3.TIF',
    &lt;OpticalBandNames.RED: 'RED'&gt;:
        'LC08_L1GT_023030_20200518_20200527_01_T2\LC08_L1GT_023030_20200518_20200527_01_T2_B4.TIF'
}

</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>band_list</code></strong> :&ensp;<code>list</code></dt>
<dd>List of the wanted bands</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>float</code></dt>
<dd>Useless here</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary containing the path of each queried band</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_band_paths(self, band_list: list, resolution: float = None) -&gt; dict:
    &#34;&#34;&#34;
    Return the paths of required bands.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; from eoreader.bands.alias import *
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
    {
        &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;:
            &#39;LC08_L1GT_023030_20200518_20200527_01_T2\\LC08_L1GT_023030_20200518_20200527_01_T2_B3.TIF&#39;,
        &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;:
            &#39;LC08_L1GT_023030_20200518_20200527_01_T2\\LC08_L1GT_023030_20200518_20200527_01_T2_B4.TIF&#39;
    }

    ```

    Args:
        band_list (list): List of the wanted bands
        resolution (float): Useless here

    Returns:
        dict: Dictionary containing the path of each queried band
    &#34;&#34;&#34;
    band_paths = {}
    for band in band_list:
        if not self.has_band(band):
            raise InvalidProductError(
                f&#34;Non existing band ({band.name}) &#34;
                f&#34;for Landsat-{self.product_type.name} products&#34;
            )
        band_nb = self.band_names[band]

        try:
            band_paths[band] = self._get_path(f&#34;_B{band_nb}&#34;)
        except FileNotFoundError as ex:
            raise InvalidProductError(
                f&#34;Non existing {band} ({band_nb}) band for {self.path}&#34;
            ) from ex

    return band_paths</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.read_mtd"><code class="name flex">
<p>def <span class="ident">read_mtd</span>(</p><p>self, <br>force_pd=False)</p>
</code></dt>
<dd>
<div class="desc"><p>Read Landsat metadata as:</p>
<ul>
<li>a <code>pandas.DataFrame</code> whatever its collection is (by default for collection 1)</li>
<li>a XML root + its namespace if the product is retrieved from the 2nd collection (by default for collection 2)</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;LC08_L1GT_023030_20200518_20200527_01_T2&quot;
&gt;&gt;&gt; prod = Reader().open(path)

&gt;&gt;&gt; # COLLECTION 1 : Open metadata as panda DataFrame
&gt;&gt;&gt; prod.read_mtd()
NAME                                           ORIGIN  ...    RESAMPLING_OPTION
value  &quot;Image courtesy of the U.S. Geological Survey&quot;  ...  &quot;CUBIC_CONVOLUTION&quot;
[1 rows x 197 columns]

&gt;&gt;&gt; # COLLECTION 2 : Open metadata as XML
&gt;&gt;&gt; path = r&quot;LC08_L1TP_200030_20201220_20210310_02_T1&quot;  # Collection 2
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.read_mtd()
(&lt;Element LANDSAT_METADATA_FILE at 0x19229016048&gt;, '')

&gt;&gt;&gt; # COLLECTION 2 : Force to pandas.DataFrame
&gt;&gt;&gt; prod.read_mtd(force_pd=True)
NAME                                           ORIGIN  ...    RESAMPLING_OPTION
value  &quot;Image courtesy of the U.S. Geological Survey&quot;  ...  &quot;CUBIC_CONVOLUTION&quot;
[1 rows x 263 columns]
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>force_pd</code></strong> :&ensp;<code>bool</code></dt>
<dd>If collection 2, return a pandas.DataFrame instead of a XML root + namespace</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>Metadata as a Pandas DataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_mtd(
    self, force_pd=False
) -&gt; Union[pd.DataFrame, Tuple[etree._Element, str]]:
    &#34;&#34;&#34;
    Read Landsat metadata as:

     - a `pandas.DataFrame` whatever its collection is (by default for collection 1)
     - a XML root + its namespace if the product is retrieved from the 2nd collection (by default for collection 2)

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;LC08_L1GT_023030_20200518_20200527_01_T2&#34;
    &gt;&gt;&gt; prod = Reader().open(path)

    &gt;&gt;&gt; # COLLECTION 1 : Open metadata as panda DataFrame
    &gt;&gt;&gt; prod.read_mtd()
    NAME                                           ORIGIN  ...    RESAMPLING_OPTION
    value  &#34;Image courtesy of the U.S. Geological Survey&#34;  ...  &#34;CUBIC_CONVOLUTION&#34;
    [1 rows x 197 columns]

    &gt;&gt;&gt; # COLLECTION 2 : Open metadata as XML
    &gt;&gt;&gt; path = r&#34;LC08_L1TP_200030_20201220_20210310_02_T1&#34;  # Collection 2
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.read_mtd()
    (&lt;Element LANDSAT_METADATA_FILE at 0x19229016048&gt;, &#39;&#39;)

    &gt;&gt;&gt; # COLLECTION 2 : Force to pandas.DataFrame
    &gt;&gt;&gt; prod.read_mtd(force_pd=True)
    NAME                                           ORIGIN  ...    RESAMPLING_OPTION
    value  &#34;Image courtesy of the U.S. Geological Survey&#34;  ...  &#34;CUBIC_CONVOLUTION&#34;
    [1 rows x 263 columns]
    ```
    Args:
        force_pd (bool): If collection 2, return a pandas.DataFrame instead of a XML root + namespace
    Returns:
        pd.DataFrame: Metadata as a Pandas DataFrame
    &#34;&#34;&#34;
    # WARNING: always use force_pd in this class !
    as_pd = (self._collection == LandsatCollection.COL_1) or force_pd

    if as_pd:
        mtd_name = f&#34;{self.name}_MTL.txt&#34;
        if self.is_archived:
            # We need to extract the file in memry to be used with pandas
            tar_ds = tarfile.open(self.path, &#34;r&#34;)
            info = [f.name for f in tar_ds.getmembers() if mtd_name in f.name][0]
            mtd_path = tar_ds.extractfile(info)
        else:
            # FOR COLLECTION 1 AND 2
            tar_ds = None
            mtd_path = os.path.join(self.path, mtd_name)

            if not os.path.isfile(mtd_path):
                raise FileNotFoundError(
                    f&#34;Unable to find the metadata file associated with {self.path}&#34;
                )

        # Parse
        mtd_data = pd.read_table(
            mtd_path,
            sep=&#34;\s=\s&#34;,
            names=[&#34;NAME&#34;, &#34;value&#34;],
            skipinitialspace=True,
            engine=&#34;python&#34;,
        )

        # Workaround an unexpected behaviour in pandas !
        if any(mtd_data.NAME == &#34;=&#34;):
            mtd_data = pd.read_table(
                mtd_path,
                sep=&#34;=&#34;,
                names=[&#34;NAME&#34;, &#34;=&#34;, &#34;value&#34;],
                usecols=[0, 2],
                skipinitialspace=True,
            )

        # Remove useless rows
        mtd_data = mtd_data[~mtd_data[&#34;NAME&#34;].isin([&#34;GROUP&#34;, &#34;END_GROUP&#34;, &#34;END&#34;])]

        # Set index
        mtd_data = mtd_data.set_index(&#34;NAME&#34;).T

        # Close if needed
        if tar_ds:
            tar_ds.close()
    else:
        if self.is_archived:
            root = files.read_archived_xml(self.path, f&#34;.*{self.name}_MTL.xml&#34;)
        else:
            # ONLY FOR COLLECTION 2
            try:
                mtd_file = glob.glob(
                    os.path.join(self.path, f&#34;{self.name}_MTL.xml&#34;)
                )[0]

                # pylint: disable=I1101:
                # Module &#39;lxml.etree&#39; has no &#39;parse&#39; member, but source is unavailable.
                xml_tree = etree.parse(mtd_file)
                root = xml_tree.getroot()
            except IndexError as ex:
                raise InvalidProductError(
                    f&#34;Metadata file ({self.name}.xml) not found in {self.path}&#34;
                ) from ex

        # Get namespace
        namespace = &#34;&#34;  # No namespace here

        mtd_data = (root, namespace)

    return mtd_data</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.get_mean_sun_angles"><code class="name flex">
<p>def <span class="ident">get_mean_sun_angles</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Get Mean Sun angles (Azimuth and Zenith angles)</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;LC08_L1GT_023030_20200518_20200527_01_T2.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_mean_sun_angles()
(140.80752656, 61.93065805)
</code></pre>
<h2 id="returns">Returns</h2>
<p>(float, float): Mean Azimuth and Zenith angle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mean_sun_angles(self) -&gt; (float, float):
    &#34;&#34;&#34;
    Get Mean Sun angles (Azimuth and Zenith angles)

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;LC08_L1GT_023030_20200518_20200527_01_T2.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_mean_sun_angles()
    (140.80752656, 61.93065805)
    ```

    Returns:
        (float, float): Mean Azimuth and Zenith angle
    &#34;&#34;&#34;
    # Retrieve angles
    mtd_data = self.read_mtd(force_pd=True)
    azimuth_angle = float(mtd_data.SUN_AZIMUTH.value)
    zenith_angle = float(mtd_data.SUN_ELEVATION.value)

    return azimuth_angle, zenith_angle</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.get_default_band"><code class="name flex">
<p>def <span class="ident">get_default_band</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_default_band" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.get_default_band">get_default_band</a></code>
</p>
<div class="desc inherited"><p>Get default band: <code>GREEN</code> for optical data as every optical satellite has a GREEN band </p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.get_default_band_path"><code class="name flex">
<p>def <span class="ident">get_default_band_path</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_default_band_path" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.get_default_band_path">get_default_band_path</a></code>
</p>
<div class="desc inherited"><p>Get default band (<code>GREEN</code> for optical data) path </p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.crs"><code class="name flex">
<p>def <span class="ident">crs</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.crs" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.crs">crs</a></code>
</p>
<div class="desc inherited"><p>Get UTM projection of the tile </p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.extent"><code class="name flex">
<p>def <span class="ident">extent</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.extent" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.extent">extent</a></code>
</p>
<div class="desc inherited"><p>Get UTM extent of the tile </p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.get_existing_bands"><code class="name flex">
<p>def <span class="ident">get_existing_bands</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_existing_bands" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.get_existing_bands">get_existing_bands</a></code>
</p>
<div class="desc inherited"><p>Return the existing band paths </p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.get_existing_band_paths"><code class="name flex">
<p>def <span class="ident">get_existing_band_paths</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_existing_band_paths" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.get_existing_band_paths">get_existing_band_paths</a></code>
</p>
<div class="desc inherited"><p>Return the existing band paths </p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.get_date"><code class="name flex">
<p>def <span class="ident">get_date</span>(</p><p>self, <br>as_date=False)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_date" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.get_date">get_date</a></code>
</p>
<div class="desc inherited"><p>Get the product's acquisition date </p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.load"><code class="name flex">
<p>def <span class="ident">load</span>(</p><p>self, <br>bands, <br>resolution=None, <br>size=None)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.load" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.load">load</a></code>
</p>
<div class="desc inherited"><p>Open the bands and compute the wanted index </p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.has_band"><code class="name flex">
<p>def <span class="ident">has_band</span>(</p><p>self, <br>band)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.has_band" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.has_band">has_band</a></code>
</p>
<div class="desc inherited"><p>Does this products has the specified band ? </p></div>
</dd>
<dt id="eoreader.products.optical.landsat_product.LandsatProduct.stack"><code class="name flex">
<p>def <span class="ident">stack</span>(</p><p>self, <br>bands, <br>resolution=None, <br>stack_path=None, <br>save_as_int=False)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.stack" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.stack">stack</a></code>
</p>
<div class="desc inherited"><p>Stack bands and index of a products </p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Home" href="/eoreader/">
<img src=https://github.com/sertit/eoreader/blob/master/docs/eoreader.png"
alt="logo"
style="width:40%;"/>
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="eoreader.products.optical" href="index.html">eoreader.products.optical</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="eoreader.products.optical.landsat_product.LandsatProductType" href="#eoreader.products.optical.landsat_product.LandsatProductType">LandsatProductType</a></code></h4>
<ul>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
<ul class="">
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProductType.L1_OLCI" href="#eoreader.products.optical.landsat_product.LandsatProductType.L1_OLCI">L1_OLCI</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProductType.L1_ETM" href="#eoreader.products.optical.landsat_product.LandsatProductType.L1_ETM">L1_ETM</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProductType.L1_TM" href="#eoreader.products.optical.landsat_product.LandsatProductType.L1_TM">L1_TM</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProductType.L1_MSS" href="#eoreader.products.optical.landsat_product.LandsatProductType.L1_MSS">L1_MSS</a></code></li>
</ul>
</li>
</ul>
</li>
<li>
<h4><code><a title="eoreader.products.optical.landsat_product.LandsatCollection" href="#eoreader.products.optical.landsat_product.LandsatCollection">LandsatCollection</a></code></h4>
<ul>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
<ul class="">
<li><code><a title="eoreader.products.optical.landsat_product.LandsatCollection.COL_1" href="#eoreader.products.optical.landsat_product.LandsatCollection.COL_1">COL_1</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatCollection.COL_2" href="#eoreader.products.optical.landsat_product.LandsatCollection.COL_2">COL_2</a></code></li>
</ul>
</li>
</ul>
</li>
<li>
<h4><code><a title="eoreader.products.optical.landsat_product.LandsatProduct" href="#eoreader.products.optical.landsat_product.LandsatProduct">LandsatProduct</a></code></h4>
<ul>
<li>
<h4><code>Functions</code></h4>
</li>
<li>
<ul class="">
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.footprint" href="#eoreader.products.optical.landsat_product.LandsatProduct.footprint">footprint</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.get_datetime" href="#eoreader.products.optical.landsat_product.LandsatProduct.get_datetime">get_datetime</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.get_band_paths" href="#eoreader.products.optical.landsat_product.LandsatProduct.get_band_paths">get_band_paths</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.read_mtd" href="#eoreader.products.optical.landsat_product.LandsatProduct.read_mtd">read_mtd</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.get_mean_sun_angles" href="#eoreader.products.optical.landsat_product.LandsatProduct.get_mean_sun_angles">get_mean_sun_angles</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.get_default_band" href="optical_product.html#eoreader.products.optical.landsat_product.LandsatProduct.get_default_band">get_default_band</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.get_default_band_path" href="optical_product.html#eoreader.products.optical.landsat_product.LandsatProduct.get_default_band_path">get_default_band_path</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.crs" href="optical_product.html#eoreader.products.optical.landsat_product.LandsatProduct.crs">crs</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.extent" href="optical_product.html#eoreader.products.optical.landsat_product.LandsatProduct.extent">extent</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.get_existing_bands" href="optical_product.html#eoreader.products.optical.landsat_product.LandsatProduct.get_existing_bands">get_existing_bands</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.get_existing_band_paths" href="optical_product.html#eoreader.products.optical.landsat_product.LandsatProduct.get_existing_band_paths">get_existing_band_paths</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.get_date" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.get_date">get_date</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.load" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.load">load</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.has_band" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.has_band">has_band</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.stack" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.stack">stack</a></code></li>
</ul>
</li>
<li>
<h4><code>Variables</code></h4>
</li>
<li>
<ul class="two-column">
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.output" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.output">output</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.name" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.name">name</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.split_name" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.split_name">split_name</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.archive_path" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.archive_path">archive_path</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.path" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.path">path</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.is_archived" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.is_archived">is_archived</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.needs_extraction" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.needs_extraction">needs_extraction</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.date" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.date">date</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.datetime" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.datetime">datetime</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.tile_name" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.tile_name">tile_name</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.sensor_type" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.sensor_type">sensor_type</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.product_type" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.product_type">product_type</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.band_names" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.band_names">band_names</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.is_reference" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.is_reference">is_reference</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.corresponding_ref" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.corresponding_ref">corresponding_ref</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.nodata" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.nodata">nodata</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.platform" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.platform">platform</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.resolution" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.resolution">resolution</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.condensed_name" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.condensed_name">condensed_name</a></code></li>
<li><code><a title="eoreader.products.optical.landsat_product.LandsatProduct.sat_id" href="../product.html#eoreader.products.optical.landsat_product.LandsatProduct.sat_id">sat_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>