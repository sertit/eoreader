<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc 0.9.2"/>
<title>eoreader.products.optical.s2_theia_product API documentation</title>
<meta name="description" content="Sentinel-2 Theia products
See [here](https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/) for more information."/>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/darcula.min.css"
crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100%;padding:3em 4em;border-left:1px solid #ddd;overflow-x:hidden}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}table{display:block;overflow-x:auto;word-break:keep-all;border-collapse:separate;border-spacing:0}th{background-color:#c4d5e780;padding:5px;border-bottom:0.1px solid gray;border-right:0.1px solid gray;border-top:0.1px solid gray}td,th{margin:0}td{white-space:nowrap;border-bottom:0.1px solid gray;border-right:0.1px solid gray}td:empty{background-color:#ececec}th:nth-child(1){border-left:0.1px solid gray}td:nth-child(1){border-left:0.1px solid gray;border-right:0.1px solid gray}th:nth-child(1),td:nth-child(1){background-color:#c4d5e7;position:-webkit-sticky;position:sticky;left:0}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML"
integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"
integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>eoreader.products.optical.s2_theia_product</code></h1>
</header>
<section id="section-intro">
<p>Sentinel-2 Theia products
See <a href="https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/">here</a> for more information.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Sentinel-2 Theia products
See [here](https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/) for more information.
&#34;&#34;&#34;

import datetime
import glob
import logging
import os
from functools import reduce
from typing import Union

import numpy as np
import xarray as xr
from lxml import etree
from rasterio.enums import Resampling

from eoreader.bands.alias import ALL_CLOUDS, CIRRUS, CLOUDS, RAW_CLOUDS, SHADOWS
from eoreader.bands.bands import BandNames
from eoreader.bands.bands import OpticalBandNames as obn
from eoreader.exceptions import InvalidProductError, InvalidTypeError
from eoreader.products.optical.optical_product import OpticalProduct
from eoreader.products.optical.s2_product import S2ProductType
from eoreader.utils import DATETIME_FMT, EOREADER_NAME
from sertit import files, rasters
from sertit.rasters import XDS_TYPE

LOGGER = logging.getLogger(EOREADER_NAME)


class S2TheiaProduct(OpticalProduct):
    &#34;&#34;&#34;
    Class of Sentinel-2 Theia Products.
    See [here](https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/) for more information.
    &#34;&#34;&#34;

    def _post_init(self) -&gt; None:
        &#34;&#34;&#34;
        Function used to post_init the products
        (setting sensor type, band names and so on)
        &#34;&#34;&#34;
        self.tile_name = self._get_tile_name()
        self.needs_extraction = False

        # Post init done by the super class
        super()._post_init()

    def _set_resolution(self) -&gt; float:
        &#34;&#34;&#34;
        Set product default resolution (in meters)
        &#34;&#34;&#34;
        # S2: use 20m resolution, even if we have 60m and 10m resolution
        # In the future maybe set one resolution per band ?
        return 20.0

    def _get_tile_name(self) -&gt; str:
        &#34;&#34;&#34;
        Retrieve tile name

        Returns:
            str: Tile name
        &#34;&#34;&#34;

        return self.split_name[3]

    def _set_product_type(self) -&gt; None:
        &#34;&#34;&#34;Get products type&#34;&#34;&#34;
        self.product_type = S2ProductType.L2A
        self.band_names.map_bands(
            {
                obn.BLUE: &#34;2&#34;,
                obn.GREEN: &#34;3&#34;,
                obn.RED: &#34;4&#34;,
                obn.VRE_1: &#34;5&#34;,
                obn.VRE_2: &#34;6&#34;,
                obn.VRE_3: &#34;7&#34;,
                obn.NIR: &#34;8&#34;,
                obn.NARROW_NIR: &#34;8A&#34;,
                obn.SWIR_1: &#34;11&#34;,
                obn.SWIR_2: &#34;12&#34;,
            }
        )

        # TODO: bands 1 and 9 are in ATB_R1 (10m) and ATB_R2 (20m)
        # B1 to be divided by 20
        # B9 to be divided by 200

    def get_datetime(self, as_datetime: bool = False) -&gt; Union[str, datetime.datetime]:
        &#34;&#34;&#34;
        Get the product&#39;s acquisition datetime, with format `YYYYMMDDTHHMMSS` &lt;-&gt; `%Y%m%dT%H%M%S`

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_datetime(as_datetime=True)
        datetime.datetime(2019, 6, 25, 10, 57, 28, 756000), fetched from metadata, so we have the ms
        &gt;&gt;&gt; prod.get_datetime(as_datetime=False)
        &#39;20190625T105728&#39;
        ```

        Args:
            as_datetime (bool): Return the date as a datetime.datetime. If false, returns a string.

        Returns:
             Union[str, datetime.datetime]: Its acquisition datetime
        &#34;&#34;&#34;
        # 20200624-105726-971
        date = datetime.datetime.strptime(self.split_name[1], &#34;%Y%m%d-%H%M%S-%f&#34;)

        if not as_datetime:
            date = date.strftime(DATETIME_FMT)

        return date

    def get_band_paths(self, band_list: list, resolution: float = None) -&gt; dict:
        &#34;&#34;&#34;
        Return the paths of required bands.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
        {
            &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;: &#39;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2\\SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2_FRE_B3.tif&#39;,
            &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;: &#39;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2\\SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2_FRE_B4.tif&#39;
        }
        ```

        Args:
            band_list (list): List of the wanted bands
            resolution (float): Band resolution

        Returns:
            dict: Dictionary containing the path of each queried band
        &#34;&#34;&#34;
        band_paths = {}
        for band in band_list:
            try:
                if self.is_archived:
                    band_paths[band] = files.get_archived_rio_path(
                        self.path, f&#34;.*FRE_B{self.band_names[band]}\.tif&#34;
                    )
                else:
                    band_paths[band] = files.get_file_in_dir(
                        self.path, f&#34;FRE_B{self.band_names[band]}.tif&#34;
                    )
            except (FileNotFoundError, IndexError) as ex:
                raise InvalidProductError(
                    f&#34;Non existing {band} ({self.band_names[band]}) band for {self.path}&#34;
                ) from ex

        return band_paths

    def _read_band(
        self,
        path: str,
        resolution: Union[tuple, list, float] = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Read band from a dataset

        .. WARNING::
            Invalid pixels are not managed here!

        Args:
            path (str): Band path
            resolution (Union[tuple, list, float]): Resolution of the wanted band, in dataset resolution unit (X, Y)
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            XDS_TYPE: Radiometrically coherent band, saved as float 32
        &#34;&#34;&#34;
        # Read band
        band = rasters.read(
            path, resolution=resolution, size=size, resampling=Resampling.bilinear
        )

        # Compute the correct radiometry of the band
        band = band / 10000.0

        return band

    # pylint: disable=R0913
    # R0913: Too many arguments (6/5) (too-many-arguments)
    def _manage_invalid_pixels(
        self,
        band_arr: XDS_TYPE,
        band: obn,
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Manage invalid pixels (Nodata, saturated, defective...)
        See [here](https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/) for more
        information.

        Args:
            band_arr (XDS_TYPE): Band array
            band (obn): Band name as an OpticalBandNames
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            XDS_TYPE: Cleaned band array
        &#34;&#34;&#34;
        nodata_true = 1
        nodata_false = 0

        # -- Manage nodata from Theia band array
        # Theia nodata is already processed
        theia_nodata = -1.0
        no_data_mask = np.where(
            band_arr.data == theia_nodata, nodata_true, nodata_false
        ).astype(np.uint8)

        # Open NODATA pixels mask
        edg_mask = self.open_mask(&#34;EDG&#34;, band, resolution=resolution, size=size)

        # Open saturated pixels
        sat_mask = self.open_mask(&#34;SAT&#34;, band, resolution=resolution, size=size)

        # Combine masks
        mask = no_data_mask | edg_mask | sat_mask

        # Open defective pixels (optional mask)
        try:
            def_mask = self.open_mask(&#34;DFP&#34;, band, resolution=resolution, size=size)
            mask = mask | def_mask
        except InvalidProductError:
            pass

        # -- Merge masks
        return self._set_nodata_mask(band_arr, mask)

    def open_mask(
        self,
        mask_id: str,
        band: obn,
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get a Sentinel-2 THEIA mask path.
        See [here](https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/) for more
        information.

        Accepted mask IDs:

        - `DFP`: Defective pixels
        - `EDG`: Nodata pixels mask
        - `SAT`: Saturated pixels mask
        - `MG2`: Geophysical mask (classification)
        - `IAB`: Mask where water vapor and TOA pixels have been interpolated
        - `CLM`: Cloud mask


        ```python
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;SENTINEL2B_20190401-105726-885_L2A_T31UEQ_D_V2-0.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.open_mask(&#34;CLM&#34;, GREEN)
        array([[[0, ..., 0]]], dtype=uint8)
        ```

        Args:
            mask_id: Mask ID
            band (obn): Band name as an OpticalBandNames
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            np.ndarray: Mask array

        &#34;&#34;&#34;
        # https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/
        # For r_1, the band order is: B2, B3, B4, B8 and for r_2: B5, B6, B7, B8a, B11, B12
        r_1 = [obn.BLUE, obn.GREEN, obn.RED, obn.NIR]
        r_2 = [obn.VRE_1, obn.VRE_2, obn.VRE_3, obn.NARROW_NIR, obn.SWIR_1, obn.SWIR_2]
        if band in r_1:
            r_x = &#34;R1&#34;
            bit_id = r_1.index(band)
        elif band in r_2:
            r_x = &#34;R2&#34;
            bit_id = r_2.index(band)
        else:
            raise InvalidProductError(f&#34;Invalid band: {band.value}&#34;)

        mask_regex = f&#34;*{mask_id}_{r_x}.tif&#34;
        try:
            if self.is_archived:
                mask_path = files.get_archived_rio_path(
                    self.path, mask_regex.replace(&#34;*&#34;, &#34;.*&#34;)
                )
            else:
                mask_path = files.get_file_in_dir(
                    os.path.join(self.path, &#34;MASKS&#34;), mask_regex, exact_name=True
                )
        except (FileNotFoundError, IndexError) as ex:
            raise InvalidProductError(
                f&#34;Non existing mask {mask_regex} in {self.name}&#34;
            ) from ex

        # Open SAT band
        sat_arr = rasters.read(
            mask_path,
            resolution=resolution,
            size=size,
            resampling=Resampling.nearest,  # Nearest to keep the flags
            masked=False,
        ).astype(np.uint8)
        sat_mask = rasters.read_bit_array(sat_arr, bit_id)

        return sat_mask

    def _load_bands(
        self, bands: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load bands as numpy arrays with the same resolution (and same metadata).

        Args:
            bands list: List of the wanted bands
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        # Return empty if no band are specified
        if not bands:
            return {}

        # Get band paths
        band_paths = self.get_band_paths(bands)

        # Open bands and get array (resampled if needed)
        band_arrays = self._open_bands(band_paths, resolution=resolution, size=size)

        return band_arrays

    def _get_condensed_name(self) -&gt; str:
        &#34;&#34;&#34;
        Get S2 products condensed name ({date}_S2_{tile]_{product_type}).

        Returns:
            str: Condensed S2 name
        &#34;&#34;&#34;
        return (
            f&#34;{self.get_datetime()}_S2THEIA_{self.tile_name}_{self.product_type.value}&#34;
        )

    def get_mean_sun_angles(self) -&gt; (float, float):
        &#34;&#34;&#34;
        Get Mean Sun angles (Azimuth and Zenith angles)

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_mean_sun_angles()
        (154.554755774838, 27.5941391571236)
        ```

        Returns:
            (float, float): Mean Azimuth and Zenith angle
        &#34;&#34;&#34;
        # Init angles
        zenith_angle = None
        azimuth_angle = None

        # Get MTD XML file
        root, _ = self.read_mtd()

        # Open zenith and azimuth angle
        for element in root:
            if element.tag == &#34;Geometric_Informations&#34;:
                for node in element:
                    if node.tag == &#34;Mean_Value_List&#34;:
                        mean_sun_angles = node.find(&#34;Sun_Angles&#34;)
                        zenith_angle = float(mean_sun_angles.findtext(&#34;ZENITH_ANGLE&#34;))
                        azimuth_angle = float(mean_sun_angles.findtext(&#34;AZIMUTH_ANGLE&#34;))
                        break  # Only one Mean_Sun_Angle
                break  # Only one Geometric_Info

        if not zenith_angle or not azimuth_angle:
            raise InvalidProductError(&#34;Azimuth or Zenith angles not found&#34;)

        return azimuth_angle, zenith_angle

    def read_mtd(self) -&gt; (etree._Element, str):
        &#34;&#34;&#34;
        Read metadata and outputs the metadata XML root and its namespace

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;SENTINEL2B_20190401-105726-885_L2A_T31UEQ_D_V2-0.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.read_mtd()
        (&lt;Element Muscate_Metadata_Document at 0x252d2071e88&gt;, &#39;&#39;)
        ```

        Returns:
            (etree._Element, str): Metadata XML root and its namespace
        &#34;&#34;&#34;
        # Get MTD XML file
        if self.is_archived:
            root = files.read_archived_xml(self.path, &#34;.*MTD_ALL\.xml&#34;)
        else:
            # Open metadata file
            try:
                mtd_xml = glob.glob(os.path.join(self.path, &#34;*MTD_ALL.xml&#34;))[0]

                # pylint: disable=I1101:
                # Module &#39;lxml.etree&#39; has no &#39;parse&#39; member, but source is unavailable.
                xml_tree = etree.parse(mtd_xml)
                root = xml_tree.getroot()
            except IndexError as ex:
                raise InvalidProductError(
                    f&#34;Metadata file not found in {self.path}&#34;
                ) from ex

        # Get namespace
        namespace = &#34;&#34;

        return root, namespace

    def _has_cloud_band(self, band: BandNames) -&gt; bool:
        &#34;&#34;&#34;
        Does this products has the specified cloud band ?
        &#34;&#34;&#34;
        return True

    def _load_clouds(
        self, bands: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load cloud files as numpy arrays with the same resolution (and same metadata).

        Read S2 Theia cloud mask:
        https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/

        &gt; A cloud mask for each resolution (CLM_R1.tif ou CLM_R2.tif):
            - bit 0 (1) : all clouds except the thinnest and all shadows
            - bit 1 (2) : all clouds (except the thinnest)
            - bit 2 (4) : clouds detected via mono-temporal thresholds
            - bit 3 (8) : clouds detected via multi-temporal thresholds
            - bit 4 (16) : thinnest clouds
            - bit 5 (32) : cloud shadows cast by a detected cloud
            - bit 6 (64) : cloud shadows cast by a cloud outside image
            - bit 7 (128) : high clouds detected by 1.38 µm

        Args:
            bands (list): List of the wanted bands
            resolution (int): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        band_dict = {}

        if bands:
            # Open 20m cloud file if resolution &gt;= 20m
            cld_file_name = &#34;CLM_R2&#34; if resolution &gt;= 20 else &#34;CLM_R1&#34;

            if self.is_archived:
                cloud_path = files.get_archived_rio_path(
                    self.path, f&#34;.*MASKS.*_{cld_file_name}.tif&#34;
                )
            else:
                cloud_path = files.get_file_in_dir(
                    os.path.join(self.path, &#34;MASKS&#34;),
                    f&#34;*_{cld_file_name}.tif&#34;,
                    exact_name=True,
                )

            if not cloud_path:
                raise FileNotFoundError(
                    f&#34;Unable to find the cloud mask for {self.path}&#34;
                )

            # Open cloud file
            clouds_array = rasters.read(
                cloud_path,
                resolution=resolution,
                size=size,
                resampling=Resampling.nearest,
            )

            # Get nodata mask
            nodata = np.where(np.isnan(clouds_array), 1, 0)

            # Bit ids
            clouds_shadows_id = 0
            clouds_id = 1
            cirrus_id = 4
            shadows_in_id = 5
            shadows_out_id = 6

            for band in bands:
                if band == ALL_CLOUDS:
                    band_dict[band] = self._create_mask(
                        clouds_array, [clouds_shadows_id, cirrus_id], nodata
                    )
                elif band == SHADOWS:
                    band_dict[band] = self._create_mask(
                        clouds_array, [shadows_in_id, shadows_out_id], nodata
                    )
                elif band == CLOUDS:
                    band_dict[band] = self._create_mask(clouds_array, clouds_id, nodata)
                elif band == CIRRUS:
                    band_dict[band] = self._create_mask(clouds_array, cirrus_id, nodata)
                elif band == RAW_CLOUDS:
                    band_dict[band] = clouds_array
                else:
                    raise InvalidTypeError(
                        f&#34;Non existing cloud band for Sentinel-2 THEIA: {band}&#34;
                    )

        return band_dict

    def _create_mask(
        self, bit_array: XDS_TYPE, bit_ids: Union[int, list], nodata: np.ndarray
    ) -&gt; xr.DataArray:
        &#34;&#34;&#34;
        Create a mask masked array (uint8) from a bit array, bit IDs and a nodata mask.

        Args:
            bit_array (XDS_TYPE): Conditional array
            bit_ids (Union[int, list]): Bit IDs
            nodata (np.ndarray): Nodata mask

        Returns:
            xr.DataArray: Mask masked array

        &#34;&#34;&#34;
        if not isinstance(bit_ids, list):
            bit_ids = [bit_ids]
        conds = rasters.read_bit_array(bit_array.astype(np.uint8), bit_ids)
        cond = reduce(lambda x, y: x | y, conds)  # Use every conditions (bitwise or)

        return super()._create_mask(bit_array, cond, nodata)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct"><code class="flex name class">
<span>class <span class="ident">S2TheiaProduct</span></span>
<span>(</span><span>product_path, archive_path=None, output_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class of Sentinel-2 Theia Products.
See <a href="https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/">here</a> for more information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class S2TheiaProduct(OpticalProduct):
    &#34;&#34;&#34;
    Class of Sentinel-2 Theia Products.
    See [here](https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/) for more information.
    &#34;&#34;&#34;

    def _post_init(self) -&gt; None:
        &#34;&#34;&#34;
        Function used to post_init the products
        (setting sensor type, band names and so on)
        &#34;&#34;&#34;
        self.tile_name = self._get_tile_name()
        self.needs_extraction = False

        # Post init done by the super class
        super()._post_init()

    def _set_resolution(self) -&gt; float:
        &#34;&#34;&#34;
        Set product default resolution (in meters)
        &#34;&#34;&#34;
        # S2: use 20m resolution, even if we have 60m and 10m resolution
        # In the future maybe set one resolution per band ?
        return 20.0

    def _get_tile_name(self) -&gt; str:
        &#34;&#34;&#34;
        Retrieve tile name

        Returns:
            str: Tile name
        &#34;&#34;&#34;

        return self.split_name[3]

    def _set_product_type(self) -&gt; None:
        &#34;&#34;&#34;Get products type&#34;&#34;&#34;
        self.product_type = S2ProductType.L2A
        self.band_names.map_bands(
            {
                obn.BLUE: &#34;2&#34;,
                obn.GREEN: &#34;3&#34;,
                obn.RED: &#34;4&#34;,
                obn.VRE_1: &#34;5&#34;,
                obn.VRE_2: &#34;6&#34;,
                obn.VRE_3: &#34;7&#34;,
                obn.NIR: &#34;8&#34;,
                obn.NARROW_NIR: &#34;8A&#34;,
                obn.SWIR_1: &#34;11&#34;,
                obn.SWIR_2: &#34;12&#34;,
            }
        )

        # TODO: bands 1 and 9 are in ATB_R1 (10m) and ATB_R2 (20m)
        # B1 to be divided by 20
        # B9 to be divided by 200

    def get_datetime(self, as_datetime: bool = False) -&gt; Union[str, datetime.datetime]:
        &#34;&#34;&#34;
        Get the product&#39;s acquisition datetime, with format `YYYYMMDDTHHMMSS` &lt;-&gt; `%Y%m%dT%H%M%S`

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_datetime(as_datetime=True)
        datetime.datetime(2019, 6, 25, 10, 57, 28, 756000), fetched from metadata, so we have the ms
        &gt;&gt;&gt; prod.get_datetime(as_datetime=False)
        &#39;20190625T105728&#39;
        ```

        Args:
            as_datetime (bool): Return the date as a datetime.datetime. If false, returns a string.

        Returns:
             Union[str, datetime.datetime]: Its acquisition datetime
        &#34;&#34;&#34;
        # 20200624-105726-971
        date = datetime.datetime.strptime(self.split_name[1], &#34;%Y%m%d-%H%M%S-%f&#34;)

        if not as_datetime:
            date = date.strftime(DATETIME_FMT)

        return date

    def get_band_paths(self, band_list: list, resolution: float = None) -&gt; dict:
        &#34;&#34;&#34;
        Return the paths of required bands.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
        {
            &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;: &#39;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2\\SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2_FRE_B3.tif&#39;,
            &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;: &#39;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2\\SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2_FRE_B4.tif&#39;
        }
        ```

        Args:
            band_list (list): List of the wanted bands
            resolution (float): Band resolution

        Returns:
            dict: Dictionary containing the path of each queried band
        &#34;&#34;&#34;
        band_paths = {}
        for band in band_list:
            try:
                if self.is_archived:
                    band_paths[band] = files.get_archived_rio_path(
                        self.path, f&#34;.*FRE_B{self.band_names[band]}\.tif&#34;
                    )
                else:
                    band_paths[band] = files.get_file_in_dir(
                        self.path, f&#34;FRE_B{self.band_names[band]}.tif&#34;
                    )
            except (FileNotFoundError, IndexError) as ex:
                raise InvalidProductError(
                    f&#34;Non existing {band} ({self.band_names[band]}) band for {self.path}&#34;
                ) from ex

        return band_paths

    def _read_band(
        self,
        path: str,
        resolution: Union[tuple, list, float] = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Read band from a dataset

        .. WARNING::
            Invalid pixels are not managed here!

        Args:
            path (str): Band path
            resolution (Union[tuple, list, float]): Resolution of the wanted band, in dataset resolution unit (X, Y)
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            XDS_TYPE: Radiometrically coherent band, saved as float 32
        &#34;&#34;&#34;
        # Read band
        band = rasters.read(
            path, resolution=resolution, size=size, resampling=Resampling.bilinear
        )

        # Compute the correct radiometry of the band
        band = band / 10000.0

        return band

    # pylint: disable=R0913
    # R0913: Too many arguments (6/5) (too-many-arguments)
    def _manage_invalid_pixels(
        self,
        band_arr: XDS_TYPE,
        band: obn,
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Manage invalid pixels (Nodata, saturated, defective...)
        See [here](https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/) for more
        information.

        Args:
            band_arr (XDS_TYPE): Band array
            band (obn): Band name as an OpticalBandNames
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            XDS_TYPE: Cleaned band array
        &#34;&#34;&#34;
        nodata_true = 1
        nodata_false = 0

        # -- Manage nodata from Theia band array
        # Theia nodata is already processed
        theia_nodata = -1.0
        no_data_mask = np.where(
            band_arr.data == theia_nodata, nodata_true, nodata_false
        ).astype(np.uint8)

        # Open NODATA pixels mask
        edg_mask = self.open_mask(&#34;EDG&#34;, band, resolution=resolution, size=size)

        # Open saturated pixels
        sat_mask = self.open_mask(&#34;SAT&#34;, band, resolution=resolution, size=size)

        # Combine masks
        mask = no_data_mask | edg_mask | sat_mask

        # Open defective pixels (optional mask)
        try:
            def_mask = self.open_mask(&#34;DFP&#34;, band, resolution=resolution, size=size)
            mask = mask | def_mask
        except InvalidProductError:
            pass

        # -- Merge masks
        return self._set_nodata_mask(band_arr, mask)

    def open_mask(
        self,
        mask_id: str,
        band: obn,
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get a Sentinel-2 THEIA mask path.
        See [here](https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/) for more
        information.

        Accepted mask IDs:

        - `DFP`: Defective pixels
        - `EDG`: Nodata pixels mask
        - `SAT`: Saturated pixels mask
        - `MG2`: Geophysical mask (classification)
        - `IAB`: Mask where water vapor and TOA pixels have been interpolated
        - `CLM`: Cloud mask


        ```python
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;SENTINEL2B_20190401-105726-885_L2A_T31UEQ_D_V2-0.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.open_mask(&#34;CLM&#34;, GREEN)
        array([[[0, ..., 0]]], dtype=uint8)
        ```

        Args:
            mask_id: Mask ID
            band (obn): Band name as an OpticalBandNames
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            np.ndarray: Mask array

        &#34;&#34;&#34;
        # https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/
        # For r_1, the band order is: B2, B3, B4, B8 and for r_2: B5, B6, B7, B8a, B11, B12
        r_1 = [obn.BLUE, obn.GREEN, obn.RED, obn.NIR]
        r_2 = [obn.VRE_1, obn.VRE_2, obn.VRE_3, obn.NARROW_NIR, obn.SWIR_1, obn.SWIR_2]
        if band in r_1:
            r_x = &#34;R1&#34;
            bit_id = r_1.index(band)
        elif band in r_2:
            r_x = &#34;R2&#34;
            bit_id = r_2.index(band)
        else:
            raise InvalidProductError(f&#34;Invalid band: {band.value}&#34;)

        mask_regex = f&#34;*{mask_id}_{r_x}.tif&#34;
        try:
            if self.is_archived:
                mask_path = files.get_archived_rio_path(
                    self.path, mask_regex.replace(&#34;*&#34;, &#34;.*&#34;)
                )
            else:
                mask_path = files.get_file_in_dir(
                    os.path.join(self.path, &#34;MASKS&#34;), mask_regex, exact_name=True
                )
        except (FileNotFoundError, IndexError) as ex:
            raise InvalidProductError(
                f&#34;Non existing mask {mask_regex} in {self.name}&#34;
            ) from ex

        # Open SAT band
        sat_arr = rasters.read(
            mask_path,
            resolution=resolution,
            size=size,
            resampling=Resampling.nearest,  # Nearest to keep the flags
            masked=False,
        ).astype(np.uint8)
        sat_mask = rasters.read_bit_array(sat_arr, bit_id)

        return sat_mask

    def _load_bands(
        self, bands: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load bands as numpy arrays with the same resolution (and same metadata).

        Args:
            bands list: List of the wanted bands
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        # Return empty if no band are specified
        if not bands:
            return {}

        # Get band paths
        band_paths = self.get_band_paths(bands)

        # Open bands and get array (resampled if needed)
        band_arrays = self._open_bands(band_paths, resolution=resolution, size=size)

        return band_arrays

    def _get_condensed_name(self) -&gt; str:
        &#34;&#34;&#34;
        Get S2 products condensed name ({date}_S2_{tile]_{product_type}).

        Returns:
            str: Condensed S2 name
        &#34;&#34;&#34;
        return (
            f&#34;{self.get_datetime()}_S2THEIA_{self.tile_name}_{self.product_type.value}&#34;
        )

    def get_mean_sun_angles(self) -&gt; (float, float):
        &#34;&#34;&#34;
        Get Mean Sun angles (Azimuth and Zenith angles)

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_mean_sun_angles()
        (154.554755774838, 27.5941391571236)
        ```

        Returns:
            (float, float): Mean Azimuth and Zenith angle
        &#34;&#34;&#34;
        # Init angles
        zenith_angle = None
        azimuth_angle = None

        # Get MTD XML file
        root, _ = self.read_mtd()

        # Open zenith and azimuth angle
        for element in root:
            if element.tag == &#34;Geometric_Informations&#34;:
                for node in element:
                    if node.tag == &#34;Mean_Value_List&#34;:
                        mean_sun_angles = node.find(&#34;Sun_Angles&#34;)
                        zenith_angle = float(mean_sun_angles.findtext(&#34;ZENITH_ANGLE&#34;))
                        azimuth_angle = float(mean_sun_angles.findtext(&#34;AZIMUTH_ANGLE&#34;))
                        break  # Only one Mean_Sun_Angle
                break  # Only one Geometric_Info

        if not zenith_angle or not azimuth_angle:
            raise InvalidProductError(&#34;Azimuth or Zenith angles not found&#34;)

        return azimuth_angle, zenith_angle

    def read_mtd(self) -&gt; (etree._Element, str):
        &#34;&#34;&#34;
        Read metadata and outputs the metadata XML root and its namespace

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;SENTINEL2B_20190401-105726-885_L2A_T31UEQ_D_V2-0.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.read_mtd()
        (&lt;Element Muscate_Metadata_Document at 0x252d2071e88&gt;, &#39;&#39;)
        ```

        Returns:
            (etree._Element, str): Metadata XML root and its namespace
        &#34;&#34;&#34;
        # Get MTD XML file
        if self.is_archived:
            root = files.read_archived_xml(self.path, &#34;.*MTD_ALL\.xml&#34;)
        else:
            # Open metadata file
            try:
                mtd_xml = glob.glob(os.path.join(self.path, &#34;*MTD_ALL.xml&#34;))[0]

                # pylint: disable=I1101:
                # Module &#39;lxml.etree&#39; has no &#39;parse&#39; member, but source is unavailable.
                xml_tree = etree.parse(mtd_xml)
                root = xml_tree.getroot()
            except IndexError as ex:
                raise InvalidProductError(
                    f&#34;Metadata file not found in {self.path}&#34;
                ) from ex

        # Get namespace
        namespace = &#34;&#34;

        return root, namespace

    def _has_cloud_band(self, band: BandNames) -&gt; bool:
        &#34;&#34;&#34;
        Does this products has the specified cloud band ?
        &#34;&#34;&#34;
        return True

    def _load_clouds(
        self, bands: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load cloud files as numpy arrays with the same resolution (and same metadata).

        Read S2 Theia cloud mask:
        https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/

        &gt; A cloud mask for each resolution (CLM_R1.tif ou CLM_R2.tif):
            - bit 0 (1) : all clouds except the thinnest and all shadows
            - bit 1 (2) : all clouds (except the thinnest)
            - bit 2 (4) : clouds detected via mono-temporal thresholds
            - bit 3 (8) : clouds detected via multi-temporal thresholds
            - bit 4 (16) : thinnest clouds
            - bit 5 (32) : cloud shadows cast by a detected cloud
            - bit 6 (64) : cloud shadows cast by a cloud outside image
            - bit 7 (128) : high clouds detected by 1.38 µm

        Args:
            bands (list): List of the wanted bands
            resolution (int): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        band_dict = {}

        if bands:
            # Open 20m cloud file if resolution &gt;= 20m
            cld_file_name = &#34;CLM_R2&#34; if resolution &gt;= 20 else &#34;CLM_R1&#34;

            if self.is_archived:
                cloud_path = files.get_archived_rio_path(
                    self.path, f&#34;.*MASKS.*_{cld_file_name}.tif&#34;
                )
            else:
                cloud_path = files.get_file_in_dir(
                    os.path.join(self.path, &#34;MASKS&#34;),
                    f&#34;*_{cld_file_name}.tif&#34;,
                    exact_name=True,
                )

            if not cloud_path:
                raise FileNotFoundError(
                    f&#34;Unable to find the cloud mask for {self.path}&#34;
                )

            # Open cloud file
            clouds_array = rasters.read(
                cloud_path,
                resolution=resolution,
                size=size,
                resampling=Resampling.nearest,
            )

            # Get nodata mask
            nodata = np.where(np.isnan(clouds_array), 1, 0)

            # Bit ids
            clouds_shadows_id = 0
            clouds_id = 1
            cirrus_id = 4
            shadows_in_id = 5
            shadows_out_id = 6

            for band in bands:
                if band == ALL_CLOUDS:
                    band_dict[band] = self._create_mask(
                        clouds_array, [clouds_shadows_id, cirrus_id], nodata
                    )
                elif band == SHADOWS:
                    band_dict[band] = self._create_mask(
                        clouds_array, [shadows_in_id, shadows_out_id], nodata
                    )
                elif band == CLOUDS:
                    band_dict[band] = self._create_mask(clouds_array, clouds_id, nodata)
                elif band == CIRRUS:
                    band_dict[band] = self._create_mask(clouds_array, cirrus_id, nodata)
                elif band == RAW_CLOUDS:
                    band_dict[band] = clouds_array
                else:
                    raise InvalidTypeError(
                        f&#34;Non existing cloud band for Sentinel-2 THEIA: {band}&#34;
                    )

        return band_dict

    def _create_mask(
        self, bit_array: XDS_TYPE, bit_ids: Union[int, list], nodata: np.ndarray
    ) -&gt; xr.DataArray:
        &#34;&#34;&#34;
        Create a mask masked array (uint8) from a bit array, bit IDs and a nodata mask.

        Args:
            bit_array (XDS_TYPE): Conditional array
            bit_ids (Union[int, list]): Bit IDs
            nodata (np.ndarray): Nodata mask

        Returns:
            xr.DataArray: Mask masked array

        &#34;&#34;&#34;
        if not isinstance(bit_ids, list):
            bit_ids = [bit_ids]
        conds = rasters.read_bit_array(bit_array.astype(np.uint8), bit_ids)
        cond = reduce(lambda x, y: x | y, conds)  # Use every conditions (bitwise or)

        return super()._create_mask(bit_array, cond, nodata)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></li>
<li><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.output"><code class="name">var <span class="ident">output</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.output" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.output">output</a></code>
</p>
<div class="desc inherited"><p>Output directory of the product, to write orthorectified data for example.</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.name"><code class="name">var <span class="ident">name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.name">name</a></code>
</p>
<div class="desc inherited"><p>Product name (its filename without any extension).</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.split_name"><code class="name">var <span class="ident">split_name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.split_name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.split_name">split_name</a></code>
</p>
<div class="desc inherited"><p>Split name, to retrieve every information from its filename (dates, tile, product type&hellip;).</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.archive_path"><code class="name">var <span class="ident">archive_path</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.archive_path" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.archive_path">archive_path</a></code>
</p>
<div class="desc inherited"><p>Archive path, same as the product path if not specified.
Useful when you want to know where both the extracted and archived version of your product …</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.path"><code class="name">var <span class="ident">path</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.path" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.path">path</a></code>
</p>
<div class="desc inherited"><p>Usable path to the product, either extracted or archived path, according to the satellite.</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.is_archived"><code class="name">var <span class="ident">is_archived</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.is_archived" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.is_archived">is_archived</a></code>
</p>
<div class="desc inherited"><p>Is the archived product is processed
(a products is considered as archived if its products path is a directory).</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.needs_extraction"><code class="name">var <span class="ident">needs_extraction</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.needs_extraction" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.needs_extraction">needs_extraction</a></code>
</p>
<div class="desc inherited"><p>Does this products needs to be extracted to be processed ? (<code>True</code> by default).</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.date"><code class="name">var <span class="ident">date</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.date" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.date">date</a></code>
</p>
<div class="desc inherited"><p>Acquisition date.</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.datetime"><code class="name">var <span class="ident">datetime</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.datetime" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.datetime">datetime</a></code>
</p>
<div class="desc inherited"><p>Acquisition datetime.</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.tile_name"><code class="name">var <span class="ident">tile_name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.tile_name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.tile_name">tile_name</a></code>
</p>
<div class="desc inherited"><p>Tile if possible (for data that can be piled, for example S2 and Landsats).</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.sensor_type"><code class="name">var <span class="ident">sensor_type</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.sensor_type" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.sensor_type">sensor_type</a></code>
</p>
<div class="desc inherited"><p>Sensor type, SAR or optical.</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.product_type"><code class="name">var <span class="ident">product_type</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.product_type" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.product_type">product_type</a></code>
</p>
<div class="desc inherited"><p>Product type, satellite-related field, such as L1C or L2A for Sentinel-2 data.</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.band_names"><code class="name">var <span class="ident">band_names</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.band_names" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.band_names">band_names</a></code>
</p>
<div class="desc inherited"><p>Band mapping between band wrapping names such as <code>GREEN</code> and band real number such as <code>03</code> for Sentinel-2.</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.is_reference"><code class="name">var <span class="ident">is_reference</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.is_reference" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.is_reference">is_reference</a></code>
</p>
<div class="desc inherited"><p>If the product is a reference, used for algorithms that need pre and post data, such as fire detection.</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.corresponding_ref"><code class="name">var <span class="ident">corresponding_ref</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.corresponding_ref" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.corresponding_ref">corresponding_ref</a></code>
</p>
<div class="desc inherited"><p>The corresponding reference products to the current one
(if the product is not a reference but has a reference data corresponding to it).
A list …</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.nodata"><code class="name">var <span class="ident">nodata</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.nodata" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.nodata">nodata</a></code>
</p>
<div class="desc inherited"><p>Product nodata, set to 0 by default. Please do not touch this or all index will fail.</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.platform"><code class="name">var <span class="ident">platform</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.platform" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.platform">platform</a></code>
</p>
<div class="desc inherited"><p>Product platform, such as Sentinel-2</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.resolution"><code class="name">var <span class="ident">resolution</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.resolution" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.resolution">resolution</a></code>
</p>
<div class="desc inherited"><p>Default resolution in meters of the current product.
For SAR product, we use Ground Range resolution as we will automatically orthorectify the tiles.</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.condensed_name"><code class="name">var <span class="ident">condensed_name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.condensed_name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.condensed_name">condensed_name</a></code>
</p>
<div class="desc inherited"><p>Condensed name, the filename with only useful data to keep the name unique
(ie. <code>20191215T110441_S2_30TXP_L2A_122756</code>).
Used to shorten names and paths.</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.sat_id"><code class="name">var <span class="ident">sat_id</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.sat_id" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.sat_id">sat_id</a></code>
</p>
<div class="desc inherited"><p>Satellite ID, i.e. <code>S2</code> for Sentinel-2</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_datetime"><code class="name flex">
<p>def <span class="ident">get_datetime</span>(</p><p>self, <br>as_datetime=False)</p>
</code></dt>
<dd>
<div class="desc"><p>Get the product's acquisition datetime, with format <code>YYYYMMDDTHHMMSS</code> &lt;-&gt; <code>%Y%m%dT%H%M%S</code></p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_datetime(as_datetime=True)
datetime.datetime(2019, 6, 25, 10, 57, 28, 756000), fetched from metadata, so we have the ms
&gt;&gt;&gt; prod.get_datetime(as_datetime=False)
'20190625T105728'
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>as_datetime</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return the date as a datetime.datetime. If false, returns a string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, datetime.datetime]</code></dt>
<dd>Its acquisition datetime</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_datetime(self, as_datetime: bool = False) -&gt; Union[str, datetime.datetime]:
    &#34;&#34;&#34;
    Get the product&#39;s acquisition datetime, with format `YYYYMMDDTHHMMSS` &lt;-&gt; `%Y%m%dT%H%M%S`

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_datetime(as_datetime=True)
    datetime.datetime(2019, 6, 25, 10, 57, 28, 756000), fetched from metadata, so we have the ms
    &gt;&gt;&gt; prod.get_datetime(as_datetime=False)
    &#39;20190625T105728&#39;
    ```

    Args:
        as_datetime (bool): Return the date as a datetime.datetime. If false, returns a string.

    Returns:
         Union[str, datetime.datetime]: Its acquisition datetime
    &#34;&#34;&#34;
    # 20200624-105726-971
    date = datetime.datetime.strptime(self.split_name[1], &#34;%Y%m%d-%H%M%S-%f&#34;)

    if not as_datetime:
        date = date.strftime(DATETIME_FMT)

    return date</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_band_paths"><code class="name flex">
<p>def <span class="ident">get_band_paths</span>(</p><p>self, <br>band_list, <br>resolution=None)</p>
</code></dt>
<dd>
<div class="desc"><p>Return the paths of required bands.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; from eoreader.bands.alias import *
&gt;&gt;&gt; path = r&quot;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
{
    &lt;OpticalBandNames.GREEN: 'GREEN'&gt;: 'SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2\SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2_FRE_B3.tif',
    &lt;OpticalBandNames.RED: 'RED'&gt;: 'SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2\SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2_FRE_B4.tif'
}
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>band_list</code></strong> :&ensp;<code>list</code></dt>
<dd>List of the wanted bands</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>float</code></dt>
<dd>Band resolution</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary containing the path of each queried band</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_band_paths(self, band_list: list, resolution: float = None) -&gt; dict:
    &#34;&#34;&#34;
    Return the paths of required bands.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; from eoreader.bands.alias import *
    &gt;&gt;&gt; path = r&#34;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
    {
        &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;: &#39;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2\\SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2_FRE_B3.tif&#39;,
        &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;: &#39;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2\\SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2_FRE_B4.tif&#39;
    }
    ```

    Args:
        band_list (list): List of the wanted bands
        resolution (float): Band resolution

    Returns:
        dict: Dictionary containing the path of each queried band
    &#34;&#34;&#34;
    band_paths = {}
    for band in band_list:
        try:
            if self.is_archived:
                band_paths[band] = files.get_archived_rio_path(
                    self.path, f&#34;.*FRE_B{self.band_names[band]}\.tif&#34;
                )
            else:
                band_paths[band] = files.get_file_in_dir(
                    self.path, f&#34;FRE_B{self.band_names[band]}.tif&#34;
                )
        except (FileNotFoundError, IndexError) as ex:
            raise InvalidProductError(
                f&#34;Non existing {band} ({self.band_names[band]}) band for {self.path}&#34;
            ) from ex

    return band_paths</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.open_mask"><code class="name flex">
<p>def <span class="ident">open_mask</span>(</p><p>self, <br>mask_id, <br>band, <br>resolution=None, <br>size=None)</p>
</code></dt>
<dd>
<div class="desc"><p>Get a Sentinel-2 THEIA mask path.
See <a href="https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/">here</a> for more
information.</p>
<p>Accepted mask IDs:</p>
<ul>
<li><code>DFP</code>: Defective pixels</li>
<li><code>EDG</code>: Nodata pixels mask</li>
<li><code>SAT</code>: Saturated pixels mask</li>
<li><code>MG2</code>: Geophysical mask (classification)</li>
<li><code>IAB</code>: Mask where water vapor and TOA pixels have been interpolated</li>
<li><code>CLM</code>: Cloud mask</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.bands.alias import *
&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;SENTINEL2B_20190401-105726-885_L2A_T31UEQ_D_V2-0.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.open_mask(&quot;CLM&quot;, GREEN)
array([[[0, ..., 0]]], dtype=uint8)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mask_id</code></strong></dt>
<dd>Mask ID</dd>
<dt><strong><code>band</code></strong> :&ensp;<code>obn</code></dt>
<dd>Band name as an OpticalBandNames</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>float</code></dt>
<dd>Band resolution in meters</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>Union[tuple, list]</code></dt>
<dd>Size of the array (width, height). Not used if resolution is provided.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Mask array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_mask(
    self,
    mask_id: str,
    band: obn,
    resolution: float = None,
    size: Union[list, tuple] = None,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Get a Sentinel-2 THEIA mask path.
    See [here](https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/) for more
    information.

    Accepted mask IDs:

    - `DFP`: Defective pixels
    - `EDG`: Nodata pixels mask
    - `SAT`: Saturated pixels mask
    - `MG2`: Geophysical mask (classification)
    - `IAB`: Mask where water vapor and TOA pixels have been interpolated
    - `CLM`: Cloud mask


    ```python
    &gt;&gt;&gt; from eoreader.bands.alias import *
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;SENTINEL2B_20190401-105726-885_L2A_T31UEQ_D_V2-0.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.open_mask(&#34;CLM&#34;, GREEN)
    array([[[0, ..., 0]]], dtype=uint8)
    ```

    Args:
        mask_id: Mask ID
        band (obn): Band name as an OpticalBandNames
        resolution (float): Band resolution in meters
        size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

    Returns:
        np.ndarray: Mask array

    &#34;&#34;&#34;
    # https://labo.obs-mip.fr/multitemp/sentinel-2/theias-sentinel-2-l2a-product-format/
    # For r_1, the band order is: B2, B3, B4, B8 and for r_2: B5, B6, B7, B8a, B11, B12
    r_1 = [obn.BLUE, obn.GREEN, obn.RED, obn.NIR]
    r_2 = [obn.VRE_1, obn.VRE_2, obn.VRE_3, obn.NARROW_NIR, obn.SWIR_1, obn.SWIR_2]
    if band in r_1:
        r_x = &#34;R1&#34;
        bit_id = r_1.index(band)
    elif band in r_2:
        r_x = &#34;R2&#34;
        bit_id = r_2.index(band)
    else:
        raise InvalidProductError(f&#34;Invalid band: {band.value}&#34;)

    mask_regex = f&#34;*{mask_id}_{r_x}.tif&#34;
    try:
        if self.is_archived:
            mask_path = files.get_archived_rio_path(
                self.path, mask_regex.replace(&#34;*&#34;, &#34;.*&#34;)
            )
        else:
            mask_path = files.get_file_in_dir(
                os.path.join(self.path, &#34;MASKS&#34;), mask_regex, exact_name=True
            )
    except (FileNotFoundError, IndexError) as ex:
        raise InvalidProductError(
            f&#34;Non existing mask {mask_regex} in {self.name}&#34;
        ) from ex

    # Open SAT band
    sat_arr = rasters.read(
        mask_path,
        resolution=resolution,
        size=size,
        resampling=Resampling.nearest,  # Nearest to keep the flags
        masked=False,
    ).astype(np.uint8)
    sat_mask = rasters.read_bit_array(sat_arr, bit_id)

    return sat_mask</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_mean_sun_angles"><code class="name flex">
<p>def <span class="ident">get_mean_sun_angles</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Get Mean Sun angles (Azimuth and Zenith angles)</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_mean_sun_angles()
(154.554755774838, 27.5941391571236)
</code></pre>
<h2 id="returns">Returns</h2>
<p>(float, float): Mean Azimuth and Zenith angle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mean_sun_angles(self) -&gt; (float, float):
    &#34;&#34;&#34;
    Get Mean Sun angles (Azimuth and Zenith angles)

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;SENTINEL2A_20190625-105728-756_L2A_T31UEQ_C_V2-2&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_mean_sun_angles()
    (154.554755774838, 27.5941391571236)
    ```

    Returns:
        (float, float): Mean Azimuth and Zenith angle
    &#34;&#34;&#34;
    # Init angles
    zenith_angle = None
    azimuth_angle = None

    # Get MTD XML file
    root, _ = self.read_mtd()

    # Open zenith and azimuth angle
    for element in root:
        if element.tag == &#34;Geometric_Informations&#34;:
            for node in element:
                if node.tag == &#34;Mean_Value_List&#34;:
                    mean_sun_angles = node.find(&#34;Sun_Angles&#34;)
                    zenith_angle = float(mean_sun_angles.findtext(&#34;ZENITH_ANGLE&#34;))
                    azimuth_angle = float(mean_sun_angles.findtext(&#34;AZIMUTH_ANGLE&#34;))
                    break  # Only one Mean_Sun_Angle
            break  # Only one Geometric_Info

    if not zenith_angle or not azimuth_angle:
        raise InvalidProductError(&#34;Azimuth or Zenith angles not found&#34;)

    return azimuth_angle, zenith_angle</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.read_mtd"><code class="name flex">
<p>def <span class="ident">read_mtd</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Read metadata and outputs the metadata XML root and its namespace</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;SENTINEL2B_20190401-105726-885_L2A_T31UEQ_D_V2-0.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.read_mtd()
(&lt;Element Muscate_Metadata_Document at 0x252d2071e88&gt;, '')
</code></pre>
<h2 id="returns">Returns</h2>
<p>(etree._Element, str): Metadata XML root and its namespace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_mtd(self) -&gt; (etree._Element, str):
    &#34;&#34;&#34;
    Read metadata and outputs the metadata XML root and its namespace

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;SENTINEL2B_20190401-105726-885_L2A_T31UEQ_D_V2-0.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.read_mtd()
    (&lt;Element Muscate_Metadata_Document at 0x252d2071e88&gt;, &#39;&#39;)
    ```

    Returns:
        (etree._Element, str): Metadata XML root and its namespace
    &#34;&#34;&#34;
    # Get MTD XML file
    if self.is_archived:
        root = files.read_archived_xml(self.path, &#34;.*MTD_ALL\.xml&#34;)
    else:
        # Open metadata file
        try:
            mtd_xml = glob.glob(os.path.join(self.path, &#34;*MTD_ALL.xml&#34;))[0]

            # pylint: disable=I1101:
            # Module &#39;lxml.etree&#39; has no &#39;parse&#39; member, but source is unavailable.
            xml_tree = etree.parse(mtd_xml)
            root = xml_tree.getroot()
        except IndexError as ex:
            raise InvalidProductError(
                f&#34;Metadata file not found in {self.path}&#34;
            ) from ex

    # Get namespace
    namespace = &#34;&#34;

    return root, namespace</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_default_band"><code class="name flex">
<p>def <span class="ident">get_default_band</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_default_band" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.get_default_band">get_default_band</a></code>
</p>
<div class="desc inherited"><p>Get default band: <code>GREEN</code> for optical data as every optical satellite has a GREEN band …</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_default_band_path"><code class="name flex">
<p>def <span class="ident">get_default_band_path</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_default_band_path" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.get_default_band_path">get_default_band_path</a></code>
</p>
<div class="desc inherited"><p>Get default band (<code>GREEN</code> for optical data) path …</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.crs"><code class="name flex">
<p>def <span class="ident">crs</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.crs" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.crs">crs</a></code>
</p>
<div class="desc inherited"><p>Get UTM projection of the tile …</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.extent"><code class="name flex">
<p>def <span class="ident">extent</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.extent" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.extent">extent</a></code>
</p>
<div class="desc inherited"><p>Get UTM extent of the tile …</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_existing_bands"><code class="name flex">
<p>def <span class="ident">get_existing_bands</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_existing_bands" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.get_existing_bands">get_existing_bands</a></code>
</p>
<div class="desc inherited"><p>Return the existing band paths …</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_existing_band_paths"><code class="name flex">
<p>def <span class="ident">get_existing_band_paths</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_existing_band_paths" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.get_existing_band_paths">get_existing_band_paths</a></code>
</p>
<div class="desc inherited"><p>Return the existing band paths …</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.footprint"><code class="name flex">
<p>def <span class="ident">footprint</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.footprint" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.footprint">footprint</a></code>
</p>
<div class="desc inherited"><p>Get UTM footprint of the products (without nodata, <em>in french == emprise utile</em>) …</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_date"><code class="name flex">
<p>def <span class="ident">get_date</span>(</p><p>self, <br>as_date=False)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_date" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.get_date">get_date</a></code>
</p>
<div class="desc inherited"><p>Get the product's acquisition date …</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.load"><code class="name flex">
<p>def <span class="ident">load</span>(</p><p>self, <br>bands, <br>resolution=None, <br>size=None)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.load" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.load">load</a></code>
</p>
<div class="desc inherited"><p>Open the bands and compute the wanted index …</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.has_band"><code class="name flex">
<p>def <span class="ident">has_band</span>(</p><p>self, <br>band)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.has_band" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.has_band">has_band</a></code>
</p>
<div class="desc inherited"><p>Does this products has the specified band ? …</p></div>
</dd>
<dt id="eoreader.products.optical.s2_theia_product.S2TheiaProduct.stack"><code class="name flex">
<p>def <span class="ident">stack</span>(</p><p>self, <br>bands, <br>resolution=None, <br>stack_path=None, <br>save_as_int=False)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.stack" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.stack">stack</a></code>
</p>
<div class="desc inherited"><p>Stack bands and index of a products …</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Home" href="/eoreader/">
<img src="https://extracteo.pages.sertit.unistra.fr/eoreader/eoreader.png"
alt="logo"
style="width:40%;"/>
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="eoreader.products.optical" href="index.html">eoreader.products.optical</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct" href="#eoreader.products.optical.s2_theia_product.S2TheiaProduct">S2TheiaProduct</a></code></h4>
<ul>
<li>
<h4><code>Functions</code></h4>
</li>
<li>
<ul class="">
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_datetime" href="#eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_datetime">get_datetime</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_band_paths" href="#eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_band_paths">get_band_paths</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.open_mask" href="#eoreader.products.optical.s2_theia_product.S2TheiaProduct.open_mask">open_mask</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_mean_sun_angles" href="#eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_mean_sun_angles">get_mean_sun_angles</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.read_mtd" href="#eoreader.products.optical.s2_theia_product.S2TheiaProduct.read_mtd">read_mtd</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_default_band" href="optical_product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_default_band">get_default_band</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_default_band_path" href="optical_product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_default_band_path">get_default_band_path</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.crs" href="optical_product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.crs">crs</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.extent" href="optical_product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.extent">extent</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_existing_bands" href="optical_product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_existing_bands">get_existing_bands</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_existing_band_paths" href="optical_product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_existing_band_paths">get_existing_band_paths</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.footprint" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.footprint">footprint</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_date" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.get_date">get_date</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.load" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.load">load</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.has_band" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.has_band">has_band</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.stack" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.stack">stack</a></code></li>
</ul>
</li>
<li>
<h4><code>Variables</code></h4>
</li>
<li>
<ul class="two-column">
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.output" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.output">output</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.name" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.name">name</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.split_name" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.split_name">split_name</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.archive_path" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.archive_path">archive_path</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.path" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.path">path</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.is_archived" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.is_archived">is_archived</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.needs_extraction" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.needs_extraction">needs_extraction</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.date" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.date">date</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.datetime" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.datetime">datetime</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.tile_name" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.tile_name">tile_name</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.sensor_type" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.sensor_type">sensor_type</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.product_type" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.product_type">product_type</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.band_names" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.band_names">band_names</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.is_reference" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.is_reference">is_reference</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.corresponding_ref" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.corresponding_ref">corresponding_ref</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.nodata" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.nodata">nodata</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.platform" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.platform">platform</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.resolution" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.resolution">resolution</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.condensed_name" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.condensed_name">condensed_name</a></code></li>
<li><code><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct.sat_id" href="../product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct.sat_id">sat_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>